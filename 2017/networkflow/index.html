<!DOCTYPE html>
<html>
<!DOCTYPE html>
<head>
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><title>
    网络流 |  潮与雪 - Rapiz
  </title>
  
<link rel="stylesheet" href="/css/style.css">
 
<script src="/js/utils.js"></script>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="robots" content="all">
  <meta name="author" content="Rapiz">
  
  <meta name="keywords" content="Rapiz,OI,ACM,HUST,乔羽佳,博客,Blog,算法">
  <meta name="description" content="Rapiz 的个人博客,开源软件,算法题解,&lt;p&gt;最大流 最小割 上下界">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({ theme: "neutral" });
    }
  </script>
  
<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<div id = "wrap">
    <header id="header">
  <div id="nav">
    <div id="nav-items">
      
      <div class="underline-trans">
        <a href="/">Home</a>
      </div>
      
      <div class="underline-trans">
        <a href="/links">Links</a>
      </div>
      
      <div class="underline-trans">
        <a href="/portal">Portal</a>
      </div>
      
    </div>
  </div>
</header>

	<main class = 'main' onchange="FanfouFix();">
		<!-- <script src="https://cdn.bootcss.com/mathjax/2.7.6/latest.js"></script>
-->
<article class="post markdown-body">
  <div class="post-title">
    <h2 class="title">网络流</h2>
  </div>
   <div class="post-meta">
         
    <blockquote><p>最大流 最小割 上下界</blockquote>
    
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最大流"><span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例1机器人放置"><span class="toc-text">例1机器人放置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络流24题"><span class="toc-text">网络流24题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小割"><span class="toc-text">最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从二分图最大独立集讲起"><span class="toc-text">从二分图最大独立集讲起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决"><span class="toc-text">解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析"><span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展"><span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-happens-now"><span class="toc-text">What happens now?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一些想法"><span class="toc-text">一些想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-Set"><span class="toc-text">Problem Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上下界"><span class="toc-text">上下界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流"><span class="toc-text">流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#费用流"><span class="toc-text">费用流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AHOI2014-支线剧情-最小费用可行流"><span class="toc-text">AHOI2014 支线剧情 最小费用可行流</span></a></li></ol></li></ol></li></ol>
    <span class="post-author">By Rapiz</span>
    <span class="post-time">2017-03-09</span>
  </div>
  <div class="post-content">
    </p>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>浅谈图论模型的建立与应用 - 黄源河</p>
<h3 id="例1机器人放置"><a href="#例1机器人放置" class="headerlink" title="例1机器人放置"></a>例1机器人放置</h3><p>神题<br>看ppt吧……<br>一个x,y匹配确定一个机器人的位置</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define file(x) &quot;placetherobots.&quot;#x
const int N = 55, V = N*N, E = V*N &lt;&lt; 1, INF = 0x3f3f3f3f;
struct EDGE{int u, v, c, f;}st[E];
int n, m, s, t, hed[V], nxt[E], sz = 1, lv[V];
char mm[N][N];
struct P{int i, s, t;
    inline bool in(int x) {return s &lt;= x &amp;&amp; x &lt;= t;}
};
std::vector&lt;P&gt; x, y;
inline void _add(int u, int v, int c) {
    st[++sz] = (EDGE){u, v, c, 0};
    nxt[sz] = hed[u], hed[u] = sz;
}
inline void add(int u, int v, int c) {_add(u, v, c), _add(v, u, 0);}
std::queue&lt;int&gt; q;
inline bool bfs() {
    memset(lv, 0, sizeof(lv));
    lv[s] = 1, q.push(s);
    while (!q.empty()) {
        int u = q.front();q.pop();
        for (int e = hed[u], v; v = st[e].v; e = nxt[e]) if (st[e].c &gt; st[e].f &amp;&amp; !lv[v]) {
            lv[v] = lv[u] + 1;
            q.push(v);
        }
    }
    return lv[t];
}
int dfs(int u, int a) {
    if (u == t) return a;
    int flow = 0, f;
    for (int e= hed[u], v; v= st[e].v; e = nxt[e])
        if (lv[v] == lv[u] + 1 &amp;&amp; st[e].c &gt; st[e].f &amp;&amp; (f = dfs(v, std::min(a, st[e].c - st[e].f)))) {
            flow += f, a -= f;
            st[e].f += f, st[e^1].f -= f;
            if (!a) break;
        }
    return flow;
}
int main() {
    freopen(file(in), &quot;r&quot;, stdin);
    freopen(file(out), &quot;w&quot;, stdout);
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, mm[i] + 1);
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) if (mm[i][j] == &#39;*&#39; || mm[i][j] == &#39;o&#39;) {
            bool f = mm[i][j] == &#39;o&#39;;
            int s = j;
            while (j + 1 &lt;= m &amp;&amp; (mm[i][j + 1] == &#39;*&#39; || mm[i][j + 1] == &#39;o&#39;)) {
                if (mm[i][++j] == &#39;o&#39;) f = 1;
            }
            if (f) x.push_back((P){i, s, j});
        }
    }
    for (int j = 1; j &lt;= m; j++) {
        for (int i = 1; i &lt;= n; i++) if (mm[i][j] == &#39;*&#39; || mm[i][j] == &#39;o&#39;) {
            bool f = mm[i][j] == &#39;o&#39;;
            int s = i;
            while (i + 1 &lt;= n &amp;&amp; (mm[i + 1][j] == &#39;*&#39; || mm[i + 1][j] == &#39;o&#39;)) {
                if (mm[++i][j] == &#39;o&#39;) f = 1;
            }
            if (f) y.push_back((P){j, s, i});
        }
    }
    for (int i = 0; i &lt; x.size(); i++) for (int j = 0; j &lt; y.size(); j++)
        if (x[i].in(y[j].i) &amp;&amp; y[j].in(x[i].i))
            if (mm[x[i].i][y[j].i] == &#39;o&#39;) add(i + 1, x.size() + 1 + j, 1);
    s = x.size() + y.size() + 1;
    t = s + 1;
    for (int i = 0; i &lt; x.size(); i++) add(s, i + 1, 1);
    for (int i = 0; i &lt; y.size(); i++) add(i + x.size() + 1, t, 1);
    int flow = 0;
    while (bfs()) flow += dfs(s, INF);
    printf(&quot;%d\n&quot;, flow);
}
</code></pre>
<h3 id="网络流24题"><a href="#网络流24题" class="headerlink" title="网络流24题"></a>网络流24题</h3><p>没什么说的。写写还是好的。</p>
<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>最大流 = 最小割</p>
<h3 id="从二分图最大独立集讲起"><a href="#从二分图最大独立集讲起" class="headerlink" title="从二分图最大独立集讲起"></a>从二分图最大独立集讲起</h3><p>做网络流24题的时候你应该已经遇到过了。<br>我们来快速回顾一下。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>二分图：顶点可以被分为两个集合，设为A,B。则A集合的点之间没有边，B集合亦然。<br>独立集：这样一个点集，它的点之间没有连边。</p>
<p>目标：我们想在二分图中取出一个最大的独立集（即点数最大，此时可以认为所有点权均为1）。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><strong>建图</strong><br>建立附加源s,附加汇t。<br>s-&gt;集合A中点，容量为1。<br>集合B中点-&gt;t，容量为1。<br>对于原图中的边，把它的方向定从A集合的点连到B集合的点，加到新图中，容量为$infty$。</p>
<p><strong>答案</strong><br>总点数-最大流。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>一个最小割对应一个最优选取方案。</strong><br>证明：<br>对于原图中的边$(u,v),u\in A, v\in B$<br>在新图中构成$s\rightarrow u \rightarrow v \rightarrow v$这条路径。<br>最小割一定是切断这条路径的。问题在于切断哪条边。<br>$(u,v)$这条边的容量是 $\infty$， 一定不会在最小割中。<br>并且剩下的两条边不会同时割掉。割掉其中一条边时已经可以破坏这条路经，再割一条边一定不是最小割。<br>现在我们有 $(s,u),(v,t)$ 一定会且只会被割掉一条边。</p>
<p>然后来构造方案。<br>我们认为割掉一个点与源汇的边就是不选取这个点。<br>最小割最小化了我们不选取的点数。<br>也就是最大化了我们选取的点数。<br>证毕。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>每个点带权。<br>将原来建图和源汇的边的容量改为该点点权。其他不变。</p>
<h3 id="What-happens-now"><a href="#What-happens-now" class="headerlink" title="What happens now?"></a>What happens now?</h3><p>浅析一类最小割问题 - 彭天翼<br>这个论文不好找。需要的给我发邮件要。</p>
<h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>你现在应该已经有些心得了。<br>如何考虑建图的正确性呢？主要是建立割和方案的对应关系。<br>一般很好把合法方案对应到最小割。<br>但是我们还需要保证最小割不会对应非法方案。</p>
<ul>
<li>非法情况导致连通</li>
<li>非法清空导致非最小割（多割了边，即去掉这条割边仍然满足不连通的条件)</li>
</ul>
<h3 id="Problem-Set"><a href="#Problem-Set" class="headerlink" title="Problem Set"></a>Problem Set</h3><p>我跟着黄学长博客刷的。感觉还行。<br>经典题双核cpu（cogs上有），文理分科，切糕。</p>
<h2 id="上下界"><a href="#上下界" class="headerlink" title="上下界"></a>上下界</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>搜了一些东西，感觉还是 Menci 讲的清楚。<del>当然一如既往的不能学她的实现。</del><br>可以先看 <a href="https://fancypei.github.io/2016/05/20/上下界网络流/">Fancy 的博客中的无源汇可行流</a>。她直接叙述建图方式，来的比较快。你能秒出来正确性就别浪费时间看长篇大论了。所谓“优化”其实比不优化还好写。所以建议直接写优化的版本。<br>接下来看 <a href="https://oi.men.ci/network-flow-with-bounds/">Menci这篇文章</a> 的无源汇可行流后的部分，条理比较清楚。代码近似于伪代码帮助理解。不过前面可能有点罗嗦？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>2502 清理雪道</td>
<td>有源汇最小流的模板题，不过还是有必要写一写的</td>
</tr>
<tr>
<td>3698 XWW的难题</td>
<td>有源汇最大流。和 poj budget 建图思路一样。用源汇限制行列和。思路还是很妙的。和poj那个题大概写一个就好了。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><h4 id="AHOI2014-支线剧情-最小费用可行流"><a href="#AHOI2014-支线剧情-最小费用可行流" class="headerlink" title="AHOI2014 支线剧情 最小费用可行流"></a>AHOI2014 支线剧情 最小费用可行流</h4><p>源是1，新建一个汇把所有点连过去，容量inf，费用为0。<br>在这个图上求一个最小费用可行流。<br>和不带权的可行流差不多：<br>对于(u,v,w,lower,upper)，建 (u, T, w, lower), (S, v, 0, lower), (u, v, w, upper - lower)<br>然后(t, s, inf)，和可行流一样。<br>跑S-T最小费用最大流就是一个可行流了。可行流费用就是答案。</p>
<pre><code class="lang-cpp">//第一次写，代码很烂
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define fore for (int e = hed[u], v; (v = st[e].v); e = nxt[e])
const int V = 400, E = V*50*4, INF = 0x3f3f3f3f;
int n, hed[V], nxt[E], sz = 1, s, t, ans, necc, p[V], a[V], dis[V];
struct EDGE{int u, v, c, w, f;}st[E];
inline void _add(int u, int v, int w, int c) {
    st[++sz] = (EDGE){u, v, c, w, 0};
    nxt[sz] = hed[u], hed[u] = sz;
}
inline void add(int u, int v, int w, int c) {_add(u, v, w, c), _add(v, u, -w, 0);}
std::queue&lt;int&gt; q;
bool inq[V];
inline bool spfa(int&amp; flow, int&amp; cost) {
    memset(dis, 0x3f, sizeof(dis));
    q.push(s);
    inq[s] = 1, dis[s] = 0, a[s] = INF;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        fore if (st[e].c &gt; st[e].f &amp;&amp; dis[v] &gt; dis[u] + st[e].w) {
            dis[v] = dis[u] + st[e].w;
            a[v] = std::min(a[u], st[e].c - st[e].f);
            p[v] = e;
            if (!inq[v]) q.push(v), inq[v] = 1;
        }
    }
    if (dis[t] == INF) return 0;
    for (int e = p[t]; e; e = p[st[e].u]) {
        flow += a[t], cost += a[t]*st[e].w;
        st[e].f += a[t], st[e^1].f -= a[t];
    }
    return 1;
}
int main() {
//    freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d&quot;, &amp;n);
    int s = 1, t = n + 1, S = t + 1, T = S + 1;
    for (int i = 1; i &lt;= n; i++) {
        int k; scanf(&quot;%d&quot;, &amp;k);
        add(i, t, 0, 1e9);
        for (int j = 1; j &lt;= k; j++) {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            add(i, x, y, 1e9);
            add(i, T, y, 1);
            add(S, x, 0, 1);
        }
    }
    add(t, s, 0, 1e9);
    int cost = 0, flow = 0;
    ::s = S, ::t = T;
    while (spfa(flow, cost)) ;
    printf(&quot;%d\n&quot;, cost);
}
</code></pre>
  </div>
  <!--hightlight.js-->
  <!--
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/idea.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script>
	
<script src="/js/hljs-line-number.js"></script>

  <script>
  hljs.initHighlightingOnLoad();
  hljs.initLineNumbersOnLoad();
  </script>
-->
<!--  <link href="//cdn.bootcss.com/highlight.js/9.9.0/styles/monokai.min.css" rel="stylesheet">
  <script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script>
  <script>hljs.initHighlighting();</script> -->

</article>

<!-- 如果不是首页且没使用 `comments: false` 关闭评论，则尝试加载评论 -->

    <!-- 配置中启用多说时，导入相应代码 -->
    <!-- 以上皆关闭且 Hexo 配置中设置了 disqus_shortname 时，导入相应代码 -->
    
        <!-- 文件分离和变量的使用，使代码能较好的兼容 Hexo 主配置 -->
        <section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'rapiz'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

    


	</main>
  <div id = "footer">
    <p>Powered by Hexo | Desgined by Rapiz</p>
</div>
<!-- Global site tag (gtag.js) - Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-168447368-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-168447368-1');
    </script>

<!-- End Google Analytics -->
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<script src=https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
