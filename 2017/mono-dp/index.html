<!DOCTYPE html>
<html>
<!DOCTYPE html>
<head><meta name="generator" content="Hexo 3.9.0">
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><title>
    动态规划中的单调性优化 |  潮与雪 - Rapiz
  </title>
  <link rel="stylesheet" href="/css/style.css"> <script src="/js/utils.js"></script>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  
  <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({ theme: "neutral" });
    }
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/components/prism-core.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<div id = "wrap">
    <header id = "header">
    <div id="nav">
		<div id = "nav-items">
      
        <div class="underline-trans"><a href="/" >Home</a></div>
      
        <div class="underline-trans"><a href="/links" >Links</a></div>
      
        <div class="underline-trans"><a href="/portal" >Portal</a></div>
      
		</ul>
	</div>
</header>


	<main class = 'main' onchange="FanfouFix();">
		<!-- <script src="https://cdn.bootcss.com/mathjax/2.7.6/latest.js"></script>
-->
<article class="post markdown-body">
  <div class="post-title">
    <h2 class="title">动态规划中的单调性优化</h2>
  </div>
   <div class="post-meta">
         
    <blockquote><p>我被优化了？</blockquote>
    
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调队列"><span class="toc-text">单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例！"><span class="toc-text">实例！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解决"><span class="toc-text">解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例！！"><span class="toc-text">实例！！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解决-1"><span class="toc-text">解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#斜率优化"><span class="toc-text">斜率优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初级"><span class="toc-text">初级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中等"><span class="toc-text">中等</span></a></li></ol></li></ol>
    <span class="post-author">By Rapiz</span>
    <span class="post-time">2017-02-27</span>
  </div>
  <div class="post-content">
    </p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>本来对于动态规划我是弃疗的。不过发现单调队列没那么吓人，其实就是个滑动窗口最值问题。<br>还有就是chenyao的ppt写错了……坑<br><em>贴的这个没错</em></p>
<blockquote>
<p>通常做dp的时候f[i]的值依赖从前面K个状态转移过来<br>由于K的限制，所以并不能全部点均从一个点转移过来<br>需要维护最优点，次优点，….<br>同时如果对于f[i] 和 f[j]，i &lt; j 且从f[j]转移更优，此时f[i]一定没有用<br>所以我们维护的点中，位置必须为单调增，贡献的值为单调减<br>by chenyao</p>
</blockquote>
<p>anyway，单调队列能优化的方程一般都长这样：</p>
<script type="math/tex; mode=display">f[i] = \max\{f[j] + c[j]\}, i - a \le j \le i - b</script><p>$f$ 是状态，$c$ 是一个常数数组。<br>如果你会滑动窗口肯定懂 $b=1$ 时怎么做，然后发现 $b \ne 1$ 时只需在每次循环开始时尝试入队往前数的第 b 个状态即可。<br>不懂滑动窗口就先去学那个。lrj 的书上不知道哪有来着。<br>然后需要说明的是题目的方程一般都不会长这么简洁，所以你一般需要把 $j$ 相关的量放到一起，再把 $i$ 相关的量放到一起。每次转移时仅与 $i$ 有关的量可以拿到 $\max$ 外面，于是就可以得到上面这种形式。</p>
<h3 id="实例！"><a href="#实例！" class="headerlink" title="实例！"></a>实例！</h3><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>还是举个例子更好。<br><em>为了抵制bzoj进行垄断，我选择链接cogs上相同的题！</em><br><a href="http://218.28.19.228/cogs/problem/problem.php?pid=773">USACO Open11 修剪草坪 from COGS</a></p>
<blockquote>
<p>简要题意：n 个数中选一些数，并且不能选连续的 k 个数，要求选的数和最大。n,k &lt;= 1e5, 数在 long long</p>
</blockquote>
<p>设 $f[i]$ 是前 i 个数的答案，那么可以从 $f[j]$ 转移过来，决策是选择 $[j + 2, i]$ 这些数。<br>方程：</p>
<script type="math/tex; mode=display">f[i] = \max\{f[j] + sum[i] - sum[j + 1]\}, i -(j + 2) + 1\le k\Rightarrow i - j - 1 \le k</script><p>注意这个方程考虑了不选 $i$ 的情况，此时 $j - 1$。<br>一看见这种东西都是顺手前缀和的……<br>暴力转移 $O(nk)$，接下来我们把它优化到$O(n)$<br>我们使用高级数学方法——小学的加法交换律和加法结合律！</p>
<script type="math/tex; mode=display">f[i] = \max\{f[j] - sum[j + 1]\} + sum[i]</script><p>看！是不是和最开始的方程形式一样了！<br>如果说和最原始的滑动窗口哪里不一样的话，就是滑动窗口在一个数组上滑，也在这个数组上赋值。而单调队列优化dp在 $f$ 上赋值，然后把 $f + c$ 放到被滑的那个数组里。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">//修剪草坪
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define file(x) &quot;mowlawn.&quot; #x
typedef long long ll;
using std::max;
const int N = 1e5 + 10;
int n, k, head, tail;
ll f[N], a[N], ans;
struct D{int i;ll v;}q[N];
int main() {
    freopen(file(in), &quot;r&quot;, stdin);
    freopen(file(out), &quot;w&quot;, stdout);
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, a + i), a[i] += a[i - 1];
    q[tail++] = (D){-1, 0};//考虑清楚怎么样才不会漏决策！这个决策代表选一个前缀
    for (int i = 1; i &lt;= n; i++) {
        while (head != tail &amp;&amp; i - q[head].i - 1 &gt; k) head++;
        while (head != tail &amp;&amp; q[tail - 1].v &lt; f[i - 1] - a[i]) tail--;
        q[tail++] = (D){i - 1, f[i - 1] - a[i]};
        f[i] = q[head].v + a[i];
        ans = max(ans, f[i]);
    }
    printf(&quot;%lld&quot;, ans);
}
</code></pre>
<h3 id="实例！！"><a href="#实例！！" class="headerlink" title="实例！！"></a>实例！！</h3><p><a href="https://www.luogu.org/problem/show?pid=2569">SCOI2010 股票交易 from 洛谷</a><br><em>这些题bzoj都有，貌似都是权限</em></p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>题意自己看吧。<br>然后方程我懒得写了，又不难。<br>注意到这次变成二维了。股票交易<br>对于每一天都可以做两（买卖）次单调队列，第 i 天的窗口在 i - w - 1天上。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="lang-cpp">//SCOI2010 股票交易
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using std::max;
const int N = 2010;
int n, w, p, as[N], bs[N], ap[N], bp[N], f[N][N], head, tail, q[N];
//yesterday（反正是以前）, have, today, now have
inline int buy(int yes, int hv, int tod, int now) {
    return f[yes][hv] - (now - hv)*ap[tod];
}
inline int sell(int yes, int hv, int tod, int now) {
    return f[yes][hv] + (hv - now)*bp[tod];
}
int main() {
//    freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;w);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d%d%d&quot;, ap + i, bp + i, as + i, bs + i);
    memset(f, 0xc0, sizeof(f));//不能达到的状态收益负无穷
    f[0][0] = 0;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 0; j &lt;= p; j++) f[i][j] = f[i - 1][j];//不买不卖
        head = tail = 0;
        for (int j = 1; j &lt;= p; j++) {
            while (head != tail &amp;&amp; q[head] &lt; j - as[i]) head++;
            while (head != tail &amp;&amp; buy(max(i - w - 1, 0), q[tail - 1], i, j) &lt; buy(max(i - w - 1, 0), j - 1, i, j)) tail--;
            q[tail++] = j - 1;
            f[i][j] = max(f[i][j], buy(max(i - w - 1, 0), q[head], i, j));
        }
        head = tail = 0;
        for (int j = p - 1; j &gt;= 0; j--) {
            while (head != tail &amp;&amp; q[head] &gt; j + bs[i]) head++;
            while (head != tail &amp;&amp; sell(max(i - w - 1, 0), q[tail - 1], i, j) &lt; sell(max(i - w - 1, 0), j + 1, i, j)) tail--;
            q[tail++] = j + 1;
            f[i][j] = max(f[i][j], sell(max(i - w - 1, 0), q[head], i, j));
        }
    }
    printf(&quot;%d\n&quot;, f[n][0]);
}
</code></pre>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p><em>学斜率优化……主要是你需要克服公式恐惧症</em></p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p><strong>这方面的变形比较多，如果我写错了，或者你觉得哪里不太清楚，欢迎评论</strong><br>来几个水题爽爽。</p>
<hr>
<p><a href="http://218.28.19.228/cogs/problem/problem.php?pid=1330">HNOI2008 玩具装箱</a><br>dp方程真的好写。</p>
<script type="math/tex; mode=display">f[i] = \max_{j < i}\{f[j] + (i - j - 1 + s[i] - s[j] - l)^2\}</script><p>$f$是答案，$s$为前缀和。<br>然后找到 $i$ 点的两个决策 $j,k$ 使得 $j &lt; k$ 并且 $k$ 优于 $j$。<br>于是带入转移方程即得</p>
<script type="math/tex; mode=display">f[j] + (i - j - 1 + s[i] - s[j] - l)^2 < f[k] + (i - k - 1 + s[i] - s[k] - l)^2</script><p>然后我们的工作就是要把它左边化成形如$\frac{y_j - y_k}{x_j - x_k}$的式子。<br>于是得到：</p>
<script type="math/tex; mode=display">\frac{f[j] + (j + s[i])^2 - f[k] - (k + s[i])^2}{(j + s[j] -  k - s[k])} < 2(i + s[i] - l)</script><p><em>注意中间由于除数为负变了一次不等式方向</em><br>所以左边成为形如$(x + s[x], f[x] + (x + s[x])^2)$这样的两个点的斜率。<br>注意我们一直进行恒等变形。<br>也就是说，对于 $k$ 优于 $j$ 且 $j &lt; k$ 的的决策都满足上式。<br>下证有效决策集在一个下凸包上。</p>
<blockquote>
<p>此时考虑上凸的三个点j1, j2, j3，即slope(j1, j2) &gt; slope(j2, j3)<br>此时若slope(j1, j2) &lt; 2<em>g[i]，那么j2比j1优，但此时j3一定比j2优<br>若slope(j1, j2) &gt;= 2</em>g[i]，则j1比j2优<br>所以前面的点如过画在平面二位直角坐标系上，一定只有下凸包上的点有意义<br>by chenyao</p>
</blockquote>
<p>然后我们需要在dp时维护这样一个凸包。这道题中插入的点的$x$坐标是单调递增的。所以我们可以用单调队列维护凸包。<br>每次计算队首两个点的斜率，若满足上式则弹出队首。否则队首即为最优决策。<br>我们来证明一下队首即为最优决策的正确性：<br>首先经过一些弹出，队首两个点一定不满足上式了。所以有$slope(q[head], q[head + 1)] &gt;= \dots$，然后我们通过上凸包的图像发现，一个点到它右边若干点的斜率是单减的，所以队首点对队中所有点都不满足上式，于是队首即为最优决策。</p>
<pre><code class="lang-c++">//玩具装箱
#include &lt;cstdio&gt;
typedef long long ll;
const int N = 5e4 + 10;
int n, q[N], sz, head, tail;
ll f[N], c[N], l;
inline double y(ll i) {return f[i] + (i + c[i])*1.0*(i + c[i]);}
inline double x(ll i) {return i + c[i];}
inline double slope(int j, int k) {//j &lt; k
    return (y(j) - y(k))/(x(j) - x(k));
}
inline ll sq(ll x) {return x*x;}
int main() {
    freopen(&quot;bzoj_1010.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;bzoj_1010.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d%lld&quot;, &amp;n, &amp;l);
    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%lld&quot;, c + i), c[i] += c[i - 1];
        while (head + 1 != tail &amp;&amp; slope(q[tail - 2], q[tail - 1]) &gt; slope(q[tail - 1], i - 1)) tail--;
        q[tail++] = i - 1;
        while (head + 1 != tail &amp;&amp; slope(q[head], q[head + 1]) &lt; 2*(i + c[i] - l)) head++;
        int j = q[head];
        f[i] = f[j] + sq(i - j - 1 + c[i] - c[j] - l);
    }
    printf(&quot;%lld&quot;, f[n]);
}
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>1010 HNOI2008 玩具装箱toy</td>
<td></td>
</tr>
<tr>
<td>4518 SDOI2016 征途</td>
<td>最简单的</td>
</tr>
<tr>
<td>1911 Apio2010 特别行动队</td>
<td>可见对二次函数型的代价都适用</td>
</tr>
<tr>
<td>1096 ZJOI2007 仓库建设</td>
<td>中等</td>
</tr>
<tr>
<td>1597 Usaco2008Mar 土地购买</td>
<td>不会的话就查题解吧……难点不在斜率优化的变形上</td>
</tr>
<tr>
<td>3156 防御准备</td>
<td>随便写写</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><p><a href="http://218.28.19.228/cogs/problem/problem.php?pid=16">NOI2007 货币兑换cash</a><br>首先你要会cdq分治。<br>然后明白cdq分治本质是计算左半部分对右半部分的影响。</p>
<p>如果你对cdq分治处理dp不太理解可以先做hackrank的一道题，101hack这个比赛的Maximizing Mission Points。<br>这个网站上有这个题的题解。</p>
<p>然后你可以看cdq的那篇论文。</p>
<p>然后你可以看看hzwer的代码。他的带注释。他的空间还比论文优一个log。<br>可惜他的状态定义不太优美，是a货币的数目。并且代码有些细节是错的。</p>
<p>所以我贴下我的代码。<br>我的状态定义就是最大收益。</p>
<pre><code class="lang-c++">//货币兑换
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using std::max;
const int N = 1e6 + 10;
const double EPS = 1e-7;
int n, sk[N];
double f[N], s, a[N], b[N], rate[N];
struct P{int i;double x, y, d;
    bool operator&lt;(const P&amp; b)const {return d &gt; b.d;}
    inline void init() {
        x = f[i]/(b[i] + rate[i]*a[i]);
        y = f[i]*rate[i]/(b[i] + rate[i]*a[i]);
    }
}p[N], q[N];
double slope(int i, int j) {
    if (fabs(p[i].x - p[j].x) &lt; EPS) return 1e20;
    return (p[i].y - p[j].y)/(p[i].x - p[j].x);
}
void solve(int l, int r) {
    if (l == r) {
        f[l] = max(f[l], f[l - 1]);
        p[l].init();
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    for (int k = l, i = 0, j = mid - l + 1; k &lt;= r; k++) q[(p[k].i &lt;= mid ? i : j)++] = p[k];
    memcpy(p + l, q, (r - l + 1)*sizeof(P));
    solve(l, mid);
    int top = 0;
    for (int i = l; i &lt;= mid; i++) {
        while (top &gt; 1 &amp;&amp; slope(sk[top], sk[top - 1]) &lt; slope(sk[top], i)) top--;
        sk[++top] = i;
    }
    for (int x = 1, y = mid + 1; y &lt;= r; y++) {
        while (x &lt; top &amp;&amp; slope(sk[x], sk[x + 1]) + EPS &gt; p[y].d) x++;
        int i = p[y].i, j = sk[x];
        f[i] = max(f[i], p[j].x*b[i] + p[j].y*a[i]);
    }
    solve(mid + 1, r);
    int tot = 0;
    for (int i = l, j = mid + 1; i &lt;= mid || j &lt;= r; tot++) {
        if (i &gt; mid || (j &lt;= r &amp;&amp; p[j].x &lt; p[i].x)) q[tot] = p[j++];
        else q[tot] = p[i++];
    }
    memcpy(p + l, q, tot*sizeof(P));
}
int main() {
    freopen(&quot;cash.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;cash.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d%lf&quot;, &amp;n, f);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf%lf%lf&quot;, a + i, b + i, rate + i), p[i].d = -b[i]/a[i], p[i].i = i;
    std::sort(p + 1, p + 1 + n);
    solve(1, n);
    printf(&quot;%.3lf\n&quot;, f[n]);
}
</code></pre>
  </div>
  <!--hightlight.js-->
  <!--
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/idea.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script>
	<script src="/js/hljs-line-number.js"></script>
  <script>
  hljs.initHighlightingOnLoad();
  hljs.initLineNumbersOnLoad();
  </script>
-->
<!--  <link href="//cdn.bootcss.com/highlight.js/9.9.0/styles/monokai.min.css" rel="stylesheet">
  <script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script>
  <script>hljs.initHighlighting();</script> -->

</article>

<!-- 如果不是首页且没使用 `comments: false` 关闭评论，则尝试加载评论 -->

    <!-- 配置中启用多说时，导入相应代码 -->
    <!-- 以上皆关闭且 Hexo 配置中设置了 disqus_shortname 时，导入相应代码 -->
    
        <!-- 文件分离和变量的使用，使代码能较好的兼容 Hexo 主配置 -->
        <section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'rapiz'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

    


	</main>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<script src=https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
