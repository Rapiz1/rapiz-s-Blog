<!DOCTYPE html><html><head><title>k-d Tree | 潮与雪 - Rapiz</title><link rel="stylesheet" href="/css/style.css"><script src="/js/utils.js"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="robots" content="index,follow"><meta name="author" content="Rapiz"><meta name="keywords" content="潮与雪,Rapiz,OI,ACM,HUST,乔羽佳,博客,Blog,算法,开源软件,题解,数据结构,树,OI"><meta name="description" content="潮与雪,Rapiz,凡人难以承受生活全部的真相，于是他们各执一端。,,k-d Tree,充满暴力倾向的空间二叉搜索树"><meta name="viewport" content="width=device-width,initial-scale=1"><script src="https://cdn.jsdelivr.net/npm/mermaid@8.5.1/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"neutral"})</script><link rel="canonical" href="https://rapiz.me/2017/kdtree/"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="潮与雪" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="潮与雪" type="application/rss+xml"></head><body><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script><div id="wrap"><header id="header"><div id="nav"><div id="nav-items"><div class="underline-trans"><a href="/">Home</a></div><div class="underline-trans"><a href="/links">Links</a></div><div class="underline-trans"><a href="/portal">About</a></div></div></div></header><main class="main" onchange="FanfouFix()"><article class="post markdown-body"><div class="post-title"><h1 class="title">k-d Tree</h1></div><div class="post-meta"><blockquote>充满暴力倾向的空间二叉搜索树</blockquote><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8D%E8%AF%B4%E4%BD%A0%E4%BB%AC%E5%8F%88%E4%B8%8D%E9%AB%98%E5%85%B4"><span class="toc-text">一句话不说你们又不高兴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B7%E5%A3%B0%E5%86%99%E5%A4%A7%E9%A2%98"><span class="toc-text">闷声写大题</span></a></li></ol><span>In <a class="post-category-link" href="/categories/OI/">OI</a> </span><span class="post-author">By Rapiz</span> <span class="post-time">2017-02-17</span> <span class="post-tags"><a class="article-tag-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a>, <a class="article-tag-none-link" href="/tags/%E6%A0%91/" rel="tag">树</a></span></div><div class="post-content"><p></p><h2 id="一句话不说你们又不高兴"><a href="#一句话不说你们又不高兴" class="headerlink" title="一句话不说你们又不高兴"></a>一句话不说你们又不高兴</h2><p>k-d Tree 可以处理 k 维空间内的最近（第二近、第三近……）邻点查询。</p><p>回忆一下二叉搜索树。<br>每个节点存个值，左子树节点的值都比它小，右子树节点的值都比它大。</p><p>问题扩展到 k 维空间内，每个点由一个 k 维向量表示其坐标。<br>如果树中节点 u 以第 d 维坐标作为分割依据，那么 u 的左子树的第 d 维坐标都比它小，右子树……</p><p>这样的树就是 k-d Tree</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://trinkle.is-programmer.com/2015/7/22/kdtree.112655.html">详情看ppt</a><br><em>注意他那样建树寻址的代价非常小。如果你用全局数组就会t飞2648</em><br><em>所以推荐大家有初始化建树的时候写结构体，否则就写数组或指针吧。结构体飞来飞去太难看了。</em></p><h2 id="闷声写大题"><a href="#闷声写大题" class="headerlink" title="闷声写大题"></a>闷声写大题</h2><div class="table-container"><table><thead><tr><th>Prob</th><th>Hint</th></tr></thead><tbody><tr><td>2648-SJY摆棋子</td><td>kdtree 不需要重建</td></tr><tr><td>4066-简单题</td><td>kdtree 区域查询 需要重建</td></tr><tr><td>3053-The-Closet-M-Points</td><td>真k dtree，不带修改</td></tr></tbody></table></div><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;2648
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
namespace I &#123;
    const int L &#x3D; 1 &lt;&lt; 15 | 1;
    char *s, *t, buf[L];
    inline char gc() &#123;
        if (s &#x3D;&#x3D; t) t &#x3D; (s &#x3D; buf) + fread(buf, 1, L, stdin);
        return *s++;
    &#125;
    inline int gi() &#123;
        int ch &#x3D; gc(), x &#x3D; 0;
        while (!isdigit(ch)) ch &#x3D; gc();
        while (isdigit(ch)) x &#x3D; x*10 + ch -&#39;0&#39;, ch &#x3D; gc();
        return x;
    &#125;
&#125;using I::gi;
using std::max;
using std::min;
const int N &#x3D; int(5e5 + 10) &lt;&lt; 1;
const double fac &#x3D; 0.7;
int n, m, D, mem, rt;
struct ND &#123;
    int d[2], mn[2], mx[2], ch[2];
    bool operator&lt;(const ND&amp; b)const &#123;return d[D] &lt; b.d[D];&#125;
    inline void rd() &#123;
        d[0] &#x3D; gi(), d[1] &#x3D; gi();
    &#125;
&#125;a[N];
inline void up(int o) &#123;
    for (int i &#x3D; 0; i &lt; 2; i++) &#123;
        a[o].mn[i] &#x3D; a[o].mx[i] &#x3D; a[o].d[i];
        for (int j &#x3D; 0; j &lt; 2; j++) if (a[o].ch[j]) &#123;
            a[o].mn[i] &#x3D; min(a[o].mn[i], a[a[o].ch[j]].mn[i]);
            a[o].mx[i] &#x3D; max(a[o].mx[i], a[a[o].ch[j]].mx[i]);
        &#125;
    &#125;
&#125;
int build(int l, int r, int t) &#123;
    if (l &gt; r) return 0;
    int mid &#x3D; l + r &gt;&gt; 1;
    D &#x3D; t;
    std::nth_element(a + l, a + mid, a + r + 1);
    a[mid].ch[0] &#x3D; build(l, mid - 1, t^1);
    a[mid].ch[1] &#x3D; build(mid + 1, r, t^1);
    up(mid);
    return mid;
&#125;
void in(int&amp; o, int p, int t) &#123;
    if (!o) o &#x3D; p;
    else in(a[o].ch[a[p].d[t] &gt; a[o].d[t]], p, t^1);
    up(o);
&#125;
int x, y, ans;
inline int val(int o) &#123;
    return o ? max(max(a[o].mn[0] - x, x - a[o].mx[0]), 0) + max(max(a[o].mn[1] - y, y - a[o].mx[1]), 0): 1e9;
&#125;
void query(int o) &#123;
    if (!o) return;
    ans &#x3D; min(abs(a[o].d[0] - x) + abs(a[o].d[1] - y), ans);
    int gd[2];
    gd[0] &#x3D; val(a[o].ch[0]), gd[1] &#x3D; val(a[o].ch[1]);
    int t &#x3D; gd[1] &lt; gd[0];
    if (gd[t] &lt; ans) query(a[o].ch[t]);
    t^&#x3D;1;
    if (gd[t] &lt; ans) query(a[o].ch[t]);
&#125;
int main() &#123;
    n &#x3D; gi(), m &#x3D; gi();
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        a[++mem].rd();
        up(i);
    &#125;
    rt &#x3D; build(1, mem, 0);
    while (m--) &#123;
        int t &#x3D; gi();
        x &#x3D; gi(), y &#x3D; gi();
        if (t &#x3D;&#x3D; 1) &#123;
            ++mem;
            a[mem].d[0] &#x3D; x, a[mem].d[1] &#x3D; y;
            up(mem);
            in(rt, mem, 0);
        &#125;
        else if (t &#x3D;&#x3D; 2) &#123;
            ans &#x3D; 1e9;
            query(rt);
            printf(&quot;%d\n&quot;, ans);
        &#125;
    &#125;
&#125;</code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;4066
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
const double fac &#x3D; 0.7;
int n, m, D, ans, sz;
struct ND&#123;
    int d[2], l[2], r[2], sz, w, s;
    ND* ch[2];
    ND(int x, int y, int v) &#123;d[0] &#x3D; x, d[1] &#x3D; y, w &#x3D; v;up();&#125;
    inline void up() &#123;
        l[0] &#x3D; r[0] &#x3D; d[0];
        l[1] &#x3D; r[1] &#x3D; d[1];
        s &#x3D; w;
        sz &#x3D; 1;
        for (int j &#x3D; 0; j &lt; 2; j++) if (ch[j]) &#123;
            s +&#x3D; ch[j]-&gt;s;
            sz +&#x3D; ch[j]-&gt;sz;
            for (int i &#x3D; 0; i &lt; 2; i++)
                l[i] &#x3D; std::min(l[i], ch[j]-&gt;l[i]),
                r[i] &#x3D; std::max(r[i], ch[j]-&gt;r[i]);
        &#125;
    &#125;
&#125;*rt;
bool cmp(ND* a, ND* b) &#123;
    return a-&gt;d[D] &lt; b-&gt;d[D];
&#125;
ND* po[int(5e5 + 1) &lt;&lt; 2];
ND* build(int l, int r, int d) &#123;
    if (l &gt; r) return 0;
    D &#x3D; d;
    int mid &#x3D; l + r &gt;&gt; 1;
    std::nth_element(po + l, po + mid, po + r + 1, cmp);
    ND* p &#x3D; po[mid];
    p-&gt;ch[0] &#x3D; build(l, mid - 1, d^1);
    p-&gt;ch[1] &#x3D; build(mid + 1, r, d^1);
    p-&gt;up();
    return p;
&#125;
void dfs(ND* u) &#123;
    if (!u) return;
    dfs(u-&gt;ch[0]);
    po[++sz] &#x3D; u;
    dfs(u-&gt;ch[1]);
&#125;
void rebuild(ND*&amp; u, int d) &#123;
    sz &#x3D; 0;
    dfs(u);
    u &#x3D; build(1, sz, d);
&#125;
void in(ND*&amp; o, ND* p, int d) &#123;
    if (!o) o &#x3D; p;
    else in(o-&gt;ch[p-&gt;d[d] &gt;&#x3D; o-&gt;d[d]], p, d^1);
    o-&gt;up();
    int s &#x3D; 0;
    for (int i &#x3D; 0; i &lt; 2; i++) if (o-&gt;ch[i]) s &#x3D; std::max(s, o-&gt;ch[i]-&gt;sz);
    if (s &gt; o-&gt;sz*fac) rebuild(o, d);
&#125;
int x0, x1, y0, y1;
int query(ND* o) &#123;
    if (!o || o-&gt;l[0] &gt; x1 || o-&gt;r[0] &lt; x0 || o-&gt;l[1] &gt; y1 || o-&gt;r[1] &lt; y0) return 0;
    if (x0 &lt;&#x3D; o-&gt;l[0] &amp;&amp; o-&gt;r[0] &lt;&#x3D; x1 &amp;&amp;
            y0 &lt;&#x3D; o-&gt;l[1] &amp;&amp; o-&gt;r[1] &lt;&#x3D; y1) return o-&gt;s;
    int s &#x3D; 0;
    if (x0 &lt;&#x3D; o-&gt;d[0] &amp;&amp; o-&gt;d[0] &lt;&#x3D; x1 &amp;&amp;
            y0 &lt;&#x3D; o-&gt;d[1] &amp;&amp; o-&gt;d[1] &lt;&#x3D; y1) s +&#x3D; o-&gt;w;
    return s + query(o-&gt;ch[0]) + query(o-&gt;ch[1]);
&#125;
int main() &#123;
&#x2F;&#x2F;  freopen(&quot;input&quot;, &quot;r&quot;, stdin);
&#x2F;&#x2F;  freopen(&quot;bzoj_4066.in&quot;, &quot;r&quot;, stdin);
&#x2F;&#x2F;  freopen(&quot;bzoj_4066.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d&quot;, &amp;n);
    while (1) &#123;
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        if (t &#x3D;&#x3D; 1) &#123;
            int x, y, w;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
            x^&#x3D;ans, y^&#x3D;ans, w^&#x3D;ans;
            ND* p &#x3D; new ND(x, y, w);
            in(rt, p, 0);
        &#125;
        else if (t &#x3D;&#x3D; 2) &#123;
            scanf(&quot;%d%d%d%d&quot;, &amp;x0, &amp;y0, &amp;x1, &amp;y1);
            x0 ^&#x3D; ans, x1^&#x3D;ans, y0^&#x3D;ans,y1^&#x3D;ans;
            printf(&quot;%d\n&quot;, ans &#x3D; query(rt));
        &#125;
        else break;
    &#125;
&#125;</code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;3053
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define nxd ((d + 1)%k)
using std::min;
using std::max;
const int N &#x3D; 5e4 + 10, K &#x3D; 5, M &#x3D; 15, INF &#x3D; 2e9 + 1;
int n, D, k, m, ans[M];
struct P&#123;
    int d[K], mn[K], mx[K], ch[2];
    bool operator&lt;(const P&amp; b)const &#123;return d[D] &lt; b.d[D];&#125;
    inline void rd() &#123;
        for (int i &#x3D; 0; i &lt; k; i++) scanf(&quot;%d&quot;, &amp;d[i]);
    &#125;
&#125;a[N];
inline void up(int o) &#123;
    for (int i &#x3D; 0; i &lt; k; i++) a[o].mn[i] &#x3D; a[o].mx[i] &#x3D; a[o].d[i];
    for (int i &#x3D; 0; i &lt; 2; i++) if (a[o].ch[i])
        for (int j &#x3D; 0; j &lt; k; j++) a[o].mn[j] &#x3D; min(a[o].mn[j], a[a[o].ch[i]].mn[j]), a[o].mx[j] &#x3D; max(a[o].mx[j], a[a[o].ch[i]].mx[j]);
&#125;
inline int sq(int x) &#123;return x*x;&#125;
inline int dis(int x, int y) &#123;
    if (!x || !y) return INF;
    int s &#x3D; 0;
    for (int i &#x3D; 0; i &lt; k; i++) s +&#x3D; sq(a[x].d[i] - a[y].d[i]);
    return s;
&#125;
int build(int l, int r, int d) &#123;
    if (l &gt; r) return 0;
    int mid &#x3D; l + r &gt;&gt; 1;
    D &#x3D; d;
    std::nth_element(a + l, a + mid, a + r + 1);
    a[mid].ch[0] &#x3D; build(l, mid - 1, nxd);
    a[mid].ch[1] &#x3D; build(mid + 1, r, nxd);
    up(mid);
    return mid;
&#125;
int acnt;
inline void addans(int o) &#123;
    int dd &#x3D; dis(o, n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; min(acnt + 1, m); i++) if (dd &lt; dis(ans[i], n + 1)) &#123;
        for (int j &#x3D; acnt; j &gt; i; j--) ans[j] &#x3D; ans[j - 1];
        ans[i] &#x3D; o;
        acnt &#x3D; min(acnt + 1, m);
        break;
    &#125;
&#x2F;&#x2F;  for (int i &#x3D; 1; i &lt; acnt; i++) assert(dis(ans[i], n + 1) &lt; dis(ans[i + 1], n + 1));
&#125;
inline int val(int o) &#123;
    if (o) &#123;
        int s &#x3D; 0;
        for (int i &#x3D; 0, c &#x3D; n + 1; i &lt; k; i++) s +&#x3D; sq(max(max(a[o].mn[i] - a[c].d[i], a[c].d[i] - a[o].mx[i]), 0));
        return s;
    &#125;
    else return INF;
&#125;
void query(int o) &#123;
    if (!o) return;
    addans(o);
    int gd[2];
    gd[0] &#x3D; val(a[o].ch[0]), gd[1] &#x3D; val(a[o].ch[1]);
    int t &#x3D; gd[1] &lt; gd[0], dd &#x3D; dis(ans[m], n + 1);
    if (dd &gt;&#x3D; gd[t]) query(a[o].ch[t]);
    t ^&#x3D; 1;
    dd &#x3D; dis(ans[m], n + 1);
    if (dd &gt;&#x3D; gd[t]) query(a[o].ch[t]);
&#125;
int rt;
void solve() &#123;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i].rd(), up(i);
    rt &#x3D; build(1, n, 0);
    int q;
    scanf(&quot;%d&quot;, &amp;q);
    while (q--) &#123;
        for (int i &#x3D; 0; i &lt; k; i++) scanf(&quot;%d&quot;, &amp;a[n + 1].d[i]);
        scanf(&quot;%d&quot;, &amp;m);
        memset(ans, 0, sizeof(ans));
        acnt &#x3D; 0;
        query(rt);
        printf(&quot;the closest %d points are:\n&quot;, m);
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;
            for (int j &#x3D; 0; j &lt; k; j++) printf(&quot;%d&quot;, a[ans[i]].d[j]), j &#x3D;&#x3D; k - 1 ? 0: putchar(&#39; &#39;);
            putchar(&#39;\n&#39;);
        &#125;
    &#125;
&#125;
int main() &#123;
    &#x2F;&#x2F;freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &#x3D;&#x3D; 2) solve();
&#125;</code></pre></div></article><div class="page-nav"><div class="underline-trans"><a href="/2017/issues-on-linux/">◀ 使用 Linux 过程中遇到的一些问题</a></div><div class="underline-trans"><a href="/2017/temporal-data-structure/">可持久化数据结构 ▶</a></div></div><section id="comments"><div id="disqus_thread"><script type="text/javascript">var disqus_shortname="rapiz";function loadDisqus(){var e=document,n=e.createElement("script");n.src="https://"+disqus_shortname+".disqus.com/embed.js",n.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(n),window.disqus_config=function(){this.page.url="https://rapiz.me/2017/kdtree/",this.page.identifier="/2017/kdtree/"}}var runningOnBrowser="undefined"!=typeof window,isBot=runningOnBrowser&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){var n;!isBot&&supportsIntersectionObserver?(n=new IntersectionObserver(function(e){e[0].isIntersecting&&(loadDisqus(),n.disconnect())},{threshold:[0]})).observe(document.getElementById("disqus_thread")):loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener external nofollow noreferrer" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></main><div id="typography-footer"><p>Powered by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1/typography">Typography</a> designed by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1">Rapiz</a></p><span id="busuanzi_container_page_pv">PV: <span id="busuanzi_value_page_pv"></span></span></div><script async src="https://www.googletagmanager.com/gtag/js?id=UA-168447368-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-168447368-1")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>