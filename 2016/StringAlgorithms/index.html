<!DOCTYPE html><html><head><title>字符串算法 | 潮与雪 - Rapiz</title><link rel="stylesheet" href="/css/style.css"><script src="/js/utils.js"></script><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="robots" content="index,follow"><meta name="author" content="Rapiz"><meta name="keywords" content="潮与雪,Rapiz,OI,ACM,HUST,乔羽佳,博客,Blog,算法,开源软件,题解,字符串,KMP,AC自动机,后缀数组,后缀自动机,Algorithm"><meta name="description" content="潮与雪,Rapiz,凡人难以承受生活全部的真相，于是他们各执一端。,,字符串算法,想起了从前被字符串支配的恐惧"><meta name="viewport" content="width=device-width,initial-scale=1"><script src="https://cdn.jsdelivr.net/npm/mermaid@8.5.1/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"neutral"})</script><link rel="canonical" href="https://rapiz.me/2016/StringAlgorithms/"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="潮与雪" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="潮与雪" type="application/rss+xml"></head><body><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script><div id="wrap"><header id="header"><div id="nav"><div id="nav-items"><div class="underline-trans"><a href="/">Home</a></div><div class="underline-trans"><a href="/links">Links</a></div><div class="underline-trans"><a href="/portal">About</a></div></div></div></header><main class="main" onchange="FanfouFix()"><article class="post markdown-body"><div class="post-title"><h1 class="title">字符串算法</h1></div><div class="post-meta"><blockquote>想起了从前被字符串支配的恐惧</blockquote><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7"><span class="toc-text">记号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#border"><span class="toc-text">border</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NOI2014-%E5%8A%A8%E7%89%A9%E5%9B%AD"><span class="toc-text">NOI2014 动物园</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BZOJ3620-%E6%A2%A6%E4%B8%AD%E6%9B%BE%E8%A7%81"><span class="toc-text">BZOJ3620 梦中曾见</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BZOJ4698-SDOI2008-Sandy%E7%9A%84%E5%8D%A1%E7%89%87"><span class="toc-text">BZOJ4698 SDOI2008 Sandy的卡片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AC-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">AC 自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="toc-text">后缀数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3238-%E5%B7%AE%E5%BC%82"><span class="toc-text">3238 差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3230-%E7%9B%B8%E4%BC%BC%E5%AD%90%E4%B8%B2"><span class="toc-text">3230 相似子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2251-%E5%A4%96%E6%98%9F%E8%81%94%E7%BB%9C"><span class="toc-text">2251 外星联络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2"><span class="toc-text">1396 识别子串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">后缀自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problems-Set"><span class="toc-text">Problems Set</span></a></li></ol></li></ol><span>In <a class="post-category-link" href="/categories/Algorithm/">Algorithm</a> </span><span class="post-author">By Rapiz</span> <span class="post-time">2016-11-01</span> <span class="post-tags"><a class="article-tag-none-link" href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC自动机</a>, <a class="article-tag-none-link" href="/tags/KMP/" rel="tag">KMP</a>, <a class="article-tag-none-link" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="tag">后缀数组</a>, <a class="article-tag-none-link" href="/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">后缀自动机</a>, <a class="article-tag-none-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></span></div><div class="post-content"><p></p><h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>在本文中，一般有<br>n 为字符串长度。<br>[l, r] 为字符串的一个子串（闭区间）。<br>[pos] 为第pos个字符。<br>pre(i) 表示字符串的长度为 i 的前缀。<br>suf(i) 表示字符串的长度为 i 的后缀。<br>下标从 1 开始。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>前置知识：理解 KMP 模板<br>O(N) 求出 1…n 的 <em>最长非原串</em>border</p><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若 pre(i) == suf(i)， 我们把 i 叫做这个字符串的一个 border。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>性质1：<br>若一个字符串存在一个长为 b 的 border， 那么 n - b 是这个字符串的一个循环节。<br><em>此时我们说的循环节允许最后一个循环节不完整出现，比如12312312也可以有循环节123</em><br>证明：<br>虽然看上去很厉害，不过证明相当简单。<br>设循环节长 $l = n - b$<br>求证即为</p><script type="math/tex;mode=display">\forall i \in [1, n - l], [i] = [i + l]</script><p>因为存在长为 b 的 border，那么根据 border 的定义有：</p><script type="math/tex;mode=display">\forall i \in [1, b], [i] = [n - b + i]</script><p>接下来做的事情，就是将 $l = n - b$ 这个式子代入上式来消去 $b,n$，就证完了！<script type="math/tex">\forall i \in [1, n - l], [i] = [l + i]</script></p><p>性质2:<br>border 的 border 还是 border<br>太简单了不写了。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><div class="table-container"><table><thead><tr><th>Prob</th><th>Hint</th></tr></thead><tbody><tr><td>1009 GT考试</td><td>KMP思路的dp，矩阵加速dp</td></tr><tr><td>1355 Radio</td><td>border直接应用</td></tr><tr><td>3670 动物园</td><td>求不重叠border</td></tr><tr><td>3620 梦中曾见</td><td>求某个范围的border是否存在</td></tr><tr><td>4698 Sandy的卡片</td><td>最长公共子串</td></tr><tr><td>3942 Censor</td><td>需要栈</td></tr></tbody></table></div><h4 id="NOI2014-动物园"><a href="#NOI2014-动物园" class="headerlink" title="NOI2014 动物园"></a>NOI2014 动物园</h4><p>维护两个东西：<br>p2, 前 i 个字符的小于等于n/2的最长 border<br>num[i], 前 i 个字符的最长 border 含有多少 border<br>KMP 主要利用了性质2。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define file(x) &quot;zoo.&quot;#x
typedef long long ll;
const int L &#x3D; 1e6 + 1;
const ll M &#x3D; 1e9 + 7;
char s[L];
ll nxt[L], num[L];
ll solve() &#123;
	int n &#x3D; strlen(s + 1);
	ll res &#x3D; 1;
	int p &#x3D; 0, p2 &#x3D; 0;
	num[1] &#x3D; 1;
	for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
		while (p &amp;&amp; s[p + 1] !&#x3D; s[i]) p &#x3D; nxt[p];
		if (s[p + 1] &#x3D;&#x3D; s[i]) p++;
		nxt[i] &#x3D; p;
		num[i] &#x3D; num[p] + 1;
		while (p2 &amp;&amp; s[p2  + 1] !&#x3D; s[i]) p2 &#x3D; nxt[p2];
		if (s[p2 + 1] &#x3D;&#x3D; s[i]) p2++;
		while (p2*2 &gt; i) p2 &#x3D; nxt[p2];
		res &#x3D; (res*(num[p2] + 1))%M;
	&#125;
	return res;
&#125;
int main() &#123;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%s&quot;, s + 1), printf(&quot;%lld\n&quot;, solve());
&#125;</code></pre></p><h4 id="BZOJ3620-梦中曾见"><a href="#BZOJ3620-梦中曾见" class="headerlink" title="BZOJ3620 梦中曾见"></a>BZOJ3620 梦中曾见</h4><p>判断有长度在[k,len(s)/2]的 border 的子串 s 有多少个。<br>我们可以求出最长的「中间有空」的 border，然后判断是否不小于 k。<br>这个 border 的求法和动物园中的差不多。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int L &#x3D; 15010;
int n, nxt[L], k;
long long ans;
char buf[L &lt;&lt; 1];
int main() &#123;
	scanf(&quot;%s%d&quot;, buf + 1, &amp;k);
	for (char* s &#x3D; buf; s &#x3D;&#x3D; buf || *s; s++) &#123;
		for (int i &#x3D; 2, p &#x3D; 0, p2 &#x3D; 0; s[i]; i++) &#123;
			while (p &amp;&amp; s[p + 1] !&#x3D; s[i]) p &#x3D; nxt[p];
			if (s[p + 1] &#x3D;&#x3D; s[i]) p++;
			nxt[i] &#x3D; p;
			while (p2 &amp;&amp; s[p2 + 1] !&#x3D; s[i]) p2 &#x3D; nxt[p2];
			if (s[p2 + 1] &#x3D;&#x3D; s[i]) p2++;
			while (p2*2 + 1 &gt; i) p2 &#x3D; nxt[p2];
			if (p2 &gt;&#x3D; k) ans++;
		&#125;
	&#125;
	printf(&quot;%lld\n&quot;, ans);
&#125;</code></pre></p><h4 id="BZOJ4698-SDOI2008-Sandy的卡片"><a href="#BZOJ4698-SDOI2008-Sandy的卡片" class="headerlink" title="BZOJ4698 SDOI2008 Sandy的卡片"></a>BZOJ4698 SDOI2008 Sandy的卡片</h4><p>题目中给出的条件可以转化为，两个序列差分后，除了第一项都相同。<br>在这个相等意义下的最长公共子串。<br>所以我们先将所有子串都差分。<br>然后枚举第一个串的一个后缀，在所有串上跑 KMP，对这些串上的匹配长度取最小值，就是当前后缀的答案。然后对所有后缀的答案取最大值。<br>注意跑 KMP 的时候强制让第一个字符匹配上，这是这题的相等条件。怎么强制看代码。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
const int N &#x3D; 1010, L &#x3D; 110;
int n, len[N], a[N][L], ans, nxt[L];
int main() &#123;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
		scanf(&quot;%d&quot;, len + i);
		for (int j &#x3D; 1; j &lt;&#x3D; len[i]; j++) scanf(&quot;%d&quot;, &amp;a[i][j]);
		for (int j &#x3D; len[i]; j; j--) a[i][j] -&#x3D; a[i][j - 1];
		a[i][1] &#x3D; 1;
	&#125;
	if (n &#x3D;&#x3D; 1) ans &#x3D; len[1];
	for (int* s &#x3D; a[1], cnt &#x3D; 1; cnt &lt;&#x3D; len[1]; s++, cnt++) &#123;
		int ll &#x3D; len[1] - (s - a[1]);
		for (int i &#x3D; 2, p &#x3D; 0; i &lt;&#x3D; ll; i++) &#123;
			while (p &amp;&amp; s[p + 1] !&#x3D;  s[i]) p &#x3D; nxt[p];
			if (!p || s[p + 1] &#x3D;&#x3D; s[i]) p++;
			nxt[i] &#x3D; p;
		&#125;
		int an &#x3D; 1e9;
		for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
			int* t &#x3D; a[i], nn &#x3D; 0;
			for (int j &#x3D; 1, p &#x3D; 0; j &lt;&#x3D; len[i]; j++) &#123;
				while (p &amp;&amp; s[p + 1] !&#x3D; t[j]) p &#x3D; nxt[p];
				if (!p || s[p + 1] &#x3D;&#x3D; t[j]) p++;
				nn &#x3D; std::max(nn, p);
				if (p &#x3D;&#x3D; ll) break;
			&#125;
			an &#x3D; std::min(an, nn);
		&#125;
		if (an !&#x3D; 1e9) ans &#x3D; std::max(ans, an);
	&#125;
	printf(&quot;%d\n&quot;, ans);
&#125;</code></pre></p><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><p>不少题会在上面dp，走多少步怎么怎么样的方法数，可以用矩阵乘法。这个没什么说的。</p><p>然后就是插入一个串记录匹配次数。暴力方法是每到一个节点都把fail能走到的节点cnt++。不那么暴力的方法就是最后再按倒bfs序 cnt[fail[x]] += cnt[x]。<br>还有一种角度，把fail指针看成父指针，我们就得到了一颗fail树。这样每次匹配就是某个节点一直到根节点的树链上的点都cnt++。<br>或者不向上更新，每次只让一个点cnt++。考虑它的影响：对，就是他所有祖先实际上都被匹配了一次。那我们可以不修改他们，而是询问他们的子树和来得到他们被匹配的次数。这其实算是树上的技巧。主要在NOI打字机那道题里用了。</p><div class="table-container"><table><thead><tr><th>Prob</th><th>Hint</th></tr></thead><tbody><tr><td>1030 文本生成器</td><td>dp</td></tr><tr><td>2938 病毒</td><td>拓扑排序</td></tr><tr><td>2434 阿狸的打字机</td><td>fail树</td></tr><tr><td>2754 喵星球上的点名</td><td>出题人——消音——</td></tr><tr><td>2580 VideoGame</td><td>dp</td></tr></tbody></table></div><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>先做完罗穗骞论文里的题。</p><div class="table-container"><table><thead><tr><th>Prob</th><th>Hint</th></tr></thead><tbody><tr><td>1031-JSOI2007-字符加密Cipher</td><td>复制粘贴一次再遍历sa，忽略不合法的后缀即可</td></tr><tr><td>1692 队列变换</td><td>贪心策略。sa用来比较前缀后缀字典序</td></tr><tr><td>3238 差异</td><td>数学+sa+单调栈</td></tr><tr><td>2251 2010BeijingWc 外星联络</td><td>出现至少两次的子串个数。sub[i] = sub[i - 1] + n - sa[i] + 1 - h[i]可得长度从h[i]+1开始</td></tr><tr><td>3230 相似子串</td><td>sa，用上式算出子串数，二分定位子串位置，计算长度。然后再算最长公共前缀和后缀</td></tr><tr><td>1396 识别子串</td><td>sa+线段树（试手标记永久化的好机会）</td></tr></tbody></table></div><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="3238-差异"><a href="#3238-差异" class="headerlink" title="3238 差异"></a>3238 差异</h4><p>那个len的求和自己推式子吧。化到一个sigma就可以用了（on）。<br>然后后面那个求和我们能看出来是对所有后缀之间的lcp长度求和。<br>所以在height数组上，对于每个i，我们求后缀sa<a href="1 &lt;= k &lt;= i">k</a>与sa[i]的lcp（也就是一段数的最小值）加起来就好了。<br>这个东西就和后缀数组没关系了，单纯的优化一些数求和的问题。<br>可以用单调栈解决。单调栈中维护有前面num个后缀到现在的最小值是val。再维护单调栈中val x num。每次答案加上val x num就行了。</p><p>如果你感觉单调栈写起来很迷，那可能是因为这里没搞清楚：<br><pre class="line-numbers language-none"><code class="language-none">sa[i-1]       sa[i]
      \ h[i] &#x2F;</code></pre><br>看完再想想单调栈究竟在维护什么，看我代码也行。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
const int N &#x3D; 5e5 + 10;
typedef long long ll;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N], top;
char s[N];
struct T&#123;ll v, n;&#125;sk[N];
ll ans;
inline bool cmp(int a, int b, int j) &#123;return rk[a] &#x3D;&#x3D; rk[b] &amp;&amp; rk[a + j] &#x3D;&#x3D; rk[b + j];&#125;
int main() &#123;
	scanf(&quot;%s&quot;, s + 1);
	n &#x3D; strlen(s + 1);
	m &#x3D; 256;
	int i, j, p;
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) sa[i] &#x3D; i, rk[i] &#x3D; s[i],
		ans +&#x3D; (n + 1ll)*(n - i) - (i + 1ll + n)*(n - i)&#x2F;2 + (n + 1ll)*(i - 1) - i*(i - 1ll)&#x2F;2;
	for (j &#x3D; 0; j &lt;&#x3D; n; m &#x3D; p, j ? j&lt;&lt;&#x3D;1:j&#x3D;1) &#123;
		for (i &#x3D; n - j + 1, p &#x3D; 0; i &lt;&#x3D; n; i++) a[++p] &#x3D; i;
		memset(c, 0, sizeof(int)*(m + 1));
		for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
			if (sa[i] - j &gt; 0) a[++p] &#x3D; sa[i] - j;
			c[rk[i]]++;
		&#125;
		for (i &#x3D; 1; i &lt;&#x3D; m; i++) c[i] +&#x3D; c[i - 1];
		for (i &#x3D; n; i; i--) sa[c[rk[a[i]]]--] &#x3D; a[i];
		for (i &#x3D; 1, p &#x3D; 0 ; i &lt;&#x3D; n; i++) b[sa[i]] &#x3D; cmp(sa[i], sa[i - 1], j) ? p:++p;
		memcpy(rk, b, sizeof(int)*(n + 1));
	&#125;
	for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; h[rk[i++]] &#x3D; p)
		for (p?p--:0, j &#x3D; sa[rk[i] - 1]; s[i + p] &#x3D;&#x3D; s[j + p]; p++);
	ll sum &#x3D; 0;
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
		ll cnt &#x3D; 0;
		if (i &gt; 1) cnt++;
		while (top &amp;&amp; sk[top - 1].v &gt;&#x3D; h[i]) &#123;
			top--;
			cnt +&#x3D; sk[top].n;
			sum -&#x3D; sk[top].n*sk[top].v;
		&#125;
		sum +&#x3D; h[i]*cnt;
		ans &#x3D; ans - 2*sum;
		sk[top++] &#x3D; (T)&#123;h[i], cnt&#125;;
	&#125;
	printf(&quot;%lld\n&quot;, ans);
&#125;</code></pre></p><h4 id="3230-相似子串"><a href="#3230-相似子串" class="headerlink" title="3230 相似子串"></a>3230 相似子串</h4><p>我们回顾一下论文内容，本质不同的子串数目。考虑按sa顺序，每次加进来一个后缀，新产生 n - sa[i] + 0 个子串，其中 h[i] 个与前面的重复，所以新产生的本质不同的子串数目是前者减去后者。<br>再想想，新产生的这些子串是哪些呢？<br>是起点在 sa[i]，终点必须严格大于 h[i] 的这些串。因为终点不到 h[i] 的都可以成为 sa[i-1] 的一个前缀，这说明他们在前面已经存在了。</p><p>然后根据以上我们就能二分出字典序中第x个子串是哪个后缀的前缀。设是第k个后缀。长度就是x-sub[k]+h[i]。加h[i]的原因见上面一行。<br>然后我们就知道了串的开头和结尾位置。剩下的就是个基本应用了。</p><p>实现上有点技巧。一定注意为了求公共前缀/后缀这里不能分隔符再倒着写一边。这样就没办法用这个后缀数组找子串位置了。所以可以先找出位置再这样reverse算。<br>注意子串个数和输入的询问都会爆int，巨坑<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min;
const int N &#x3D; 2e5 + 10;
int n, m, q,  a[N], b[N], c[N], sa[N], rk[N], h[23][N], start[N][2], end[N][2];
long long ans[N], sub[N];
char s[N];
inline bool cmp(int a, int b, int j) &#123;return rk[a] &#x3D;&#x3D; rk[b] &amp;&amp; rk[a + j] &#x3D;&#x3D; rk[b + j];&#125;
inline long long query(int l, int r) &#123;
	if (l &#x3D;&#x3D; r) return n - l + 1;
	l &#x3D; rk[l], r &#x3D; rk[r];
	if (l &gt; r) std::swap(l, r);
	l++;
	int k &#x3D; r - l + 1, p &#x3D; 0;
	while ((1 &lt;&lt; p + 1) &lt;&#x3D; k) p++;
	return min(h[p][l], h[p][r - (1 &lt;&lt; p) + 1]);
&#125;
void build() &#123;
	m &#x3D; 256;
	int i, j, p;
	memset(rk, 0, sizeof(rk));
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) sa[i] &#x3D; i, rk[i] &#x3D; s[i];
	for (j &#x3D; 0; j &lt;&#x3D; n; m &#x3D; p, j?j&lt;&lt;&#x3D;1:j&#x3D;1)&#123;
		for (i &#x3D; n - j + 1, p &#x3D; 0; i &lt;&#x3D; n; i++) a[++p] &#x3D; i;
		memset(c, 0, sizeof(int)*(m + 1));
		for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
			c[rk[i]]++;
			if (sa[i] - j &gt; 0) a[++p] &#x3D; sa[i] - j;
		&#125;
		for (i &#x3D; 1; i &lt;&#x3D; m; i++) c[i] +&#x3D; c[i - 1];
		for (i &#x3D; n; i; i--) sa[c[rk[a[i]]]--] &#x3D; a[i];
		for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++) b[sa[i]] &#x3D; cmp(sa[i], sa[i - 1], j) ? p : ++p;
		memcpy(rk, b, sizeof(int)*(n + 1));
	&#125;
	for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; h[0][rk[i++]] &#x3D; p)
		for (p?p--:0, j &#x3D; sa[rk[i] - 1]; s[i + p] &#x3D;&#x3D; s[j + p]; p++);
	for (i &#x3D; 1; i &lt; 23; i++) for (j &#x3D; 1; j &lt;&#x3D; n; j++) if (j + (1 &lt;&lt; i - 1) &lt;&#x3D; n)
		h[i][j] &#x3D; min(h[i - 1][j], h[i - 1][j + (1 &lt;&lt; i - 1)]);
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) sub[i] &#x3D; sub[i - 1] + n - sa[i] + 1 - h[0][i];
&#125;
int main() &#123;
&#x2F;&#x2F;	freopen(&quot;input&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d%d%s&quot;, &amp;n, &amp;q, s + 1);
	build();
	for (int i &#x3D; 1; i &lt;&#x3D; q; i++) &#123;
		long long x, y;
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		int px &#x3D; std::lower_bound(sub + 1, sub + n + 1, x) - sub, py &#x3D; std::lower_bound(sub + 1, sub + 1 + n, y) - sub;
		if (px &gt; n || py &gt; n) &#123;
			ans[i] &#x3D; -1;
			continue;
		&#125;
		x &#x3D; x - sub[px - 1] + h[0][px], y &#x3D; y - sub[py - 1] + h[0][py];
		px &#x3D; sa[px], py &#x3D; sa[py];
		start[i][0] &#x3D; px, start[i][1] &#x3D; py, end[i][0] &#x3D; px + x - 1, end[i][1] &#x3D; py + y - 1;
		long long pre &#x3D; min(query(px, py), min(x, y));
		ans[i] +&#x3D; pre*pre;
	&#125;
	std::reverse(s + 1, s + 1 + n);
	build();
	for (int i &#x3D; 1; i &lt;&#x3D; q; i++) if (ans[i] !&#x3D; -1) &#123;
		long long suf &#x3D; min(query(n - end[i][0] + 1, n - end[i][1] + 1), (long long)min(end[i][0] - start[i][0] + 1, end[i][1] - start[i][1] + 1));
		ans[i] +&#x3D; suf*suf;
	&#125;
	for (int i &#x3D; 1; i &lt;&#x3D; q; i++) printf(&quot;%lld\n&quot;, ans[i]);
&#125;
&#x2F;&#x2F;子串个数会爆int，输入询问同理</code></pre></p><h4 id="2251-外星联络"><a href="#2251-外星联络" class="headerlink" title="2251 外星联络"></a>2251 外星联络</h4><p>直接看代码末尾的那几行吧。<br>为什么从 h[i] + 1 开始枚举？<br>想想上一题就知道了。这保证我们每次枚举到的串都不存在于前面，也就是没有把本质相同的串多输出了。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
const int N &#x3D; 6010;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N];
char s[N];
inline bool cmp(int a, int b, int j) &#123;return rk[a] &#x3D;&#x3D; rk[b] &amp;&amp; rk[a + j] &#x3D;&#x3D; rk[b + j];&#125;
int main() &#123;
&#x2F;&#x2F;	freopen(&quot;input&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d%s&quot;, &amp;n, s + 1);
	m &#x3D; 256;
	int i, j, p;
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) sa[i] &#x3D; i, rk[i] &#x3D; s[i];
	for (j &#x3D; 0; j &lt;&#x3D; n; m &#x3D; p, j?j&lt;&lt;&#x3D;1:j&#x3D;1) &#123;
		for (i &#x3D; n - j + 1, p &#x3D; 0; i &lt;&#x3D; n; i++) a[++p] &#x3D; i;
		for (i &#x3D; 1; i &lt;&#x3D; n; i++) if (sa[i] - j &gt; 0) a[++p] &#x3D; sa[i] - j;
		memset(c, 0, sizeof(int)*(m + 1));
		for (i &#x3D; 1; i &lt;&#x3D; n; i++) c[rk[i]]++;
		for (i &#x3D; 1; i &lt;&#x3D; m; i++) c[i] +&#x3D; c[i - 1];
		for (i &#x3D; n; i; i--) sa[c[rk[a[i]]]--] &#x3D; a[i];
		for (i &#x3D; 1, p &#x3D; 0; i &lt;&#x3D; n; i++) b[sa[i]] &#x3D; cmp(sa[i], sa[i - 1], j) ? p : ++p;
		memcpy(rk, b, sizeof(int)*(n + 1));
	&#125;
	for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; h[rk[i++]] &#x3D; p)
		for(p?p--:0, j &#x3D; sa[rk[i] - 1]; s[i + p] &#x3D;&#x3D; s[j + p]; p++);
	for (i &#x3D; 1; i &lt;&#x3D; n; i++)
		for (int j &#x3D; h[i] + 1; sa[i] + j - 1 &lt;&#x3D; n; j++) &#123;
			int r &#x3D; i, l &#x3D; i;
			&#x2F;&#x2F;while (l &gt;&#x3D; 1 &amp;&amp; h[l] &gt;&#x3D; j) l--;
			while (r + 1 &lt;&#x3D; n &amp;&amp; h[r + 1] &gt;&#x3D; j) r++;
			if (r - l + 1 &gt; 1) printf(&quot;%d\n&quot;, r - l + 1);
		&#125;
&#125;
</code></pre></p><h4 id="1396-识别子串"><a href="#1396-识别子串" class="headerlink" title="1396 识别子串"></a>1396 识别子串</h4><p>题目要求识别子串不能重复出现。<br>我们不妨考虑不重复出现的子串覆盖到了哪些字符。<br>还是按sa顺序来考虑sa[i]的前缀来考虑所有子串。<br>sa[i]有多少前缀重复出现过了？L = max(h[i], h[i + 1])就是其他地方出过的最长前缀。<br>这意味着从 L + 1 开始的子串都是合法的——没有重复出现过。<br>这样，{sa[i],L+1}这一个串可以成为它覆盖到的字符的识别串，长度显然。这里用个线段树把区间答案min了。<br>然后考虑sa[i]的其他合法前缀，L+2 … n 依然对覆盖到的字符有贡献，设这个字符位置为 p， 贡献就是 p - sa[i] + 1，其中 p &gt;= L + 2。<em>p也可以取到L+1，这时和上一行的情况贡献一样。</em><br>然后我们可以用个vector，把sa[i]放到位置L+2里。这个计算过程估计用代码（在我代码的末尾部分）可以看得更清楚，毕竟是非常直观的算法。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
const int N &#x3D; 2e5 + 10;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N], ans[N], val[N &lt;&lt; 2];
char s[N];
std::vector&lt;int&gt; vec[N];
inline bool cmp(int a, int b, int j) &#123;return rk[a] &#x3D;&#x3D; rk[b] &amp;&amp; rk[a + j] &#x3D;&#x3D; rk[b + j];&#125;
int q1, q2, q3;
void change(int o, int l, int r) &#123;
	if (q1 &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; q2) val[o] &#x3D; std::min(val[o], q3);
	else &#123;
		int mid &#x3D; l + r &gt;&gt; 1;
		if (mid &gt;&#x3D; q1) change(o&lt;&lt;1, l, mid);
		if (mid + 1 &lt;&#x3D; q2) change(o&lt;&lt;1|1, mid + 1, r);
	&#125;
&#125;
void get(int o, int l, int r, int nv) &#123;
	nv &#x3D; std::min(nv, val[o]);
	int mid &#x3D; l + r &gt;&gt; 1;
	if (l &#x3D;&#x3D; r) ans[l] &#x3D; nv;
	else get(o&lt;&lt;1, l, mid, nv), get(o&lt;&lt;1|1, mid+1, r, nv);
&#125;
int main() &#123;
&#x2F;&#x2F; 	freopen(&quot;input&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%s&quot;, s + 1);
	int i, j, p;
	for (i &#x3D; 1; s[i]; i++) n++, sa[i] &#x3D; i, rk[i] &#x3D; s[i];
	m &#x3D; 256;
	for (j &#x3D; 0; j &lt;&#x3D; n; m &#x3D; p, j?j&lt;&lt;&#x3D;1:j&#x3D;1) &#123;
		for (i &#x3D; n - j + 1, p &#x3D; 0; i &lt;&#x3D; n; i++) a[++p] &#x3D; i;
		memset(c, 0, sizeof(int)*(m + 1));
		for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
			c[rk[i]]++;
			if (sa[i] &gt; j) a[++p] &#x3D; sa[i] - j;
		&#125;
		for (i &#x3D; 1; i &lt;&#x3D; m; i++) c[i] +&#x3D; c[i - 1];
		for (i &#x3D; n; i; i--) sa[c[rk[a[i]]]--] &#x3D; a[i];
		for (i &#x3D; 1, p &#x3D; 0; i &lt;&#x3D; n; i++) b[sa[i]] &#x3D; cmp(sa[i], sa[i - 1], j) ? p : ++p;
		memcpy(rk, b, sizeof(int)*(n + 1));
	&#125;
	for (i &#x3D; 1, p &#x3D; 0; i &lt;&#x3D; n; h[rk[i++]] &#x3D; p)
		for (p?p--:0, j &#x3D; sa[rk[i] - 1]; s[i + p] &#x3D;&#x3D; s[j + p]; p++);
	memset(ans, 0x3f, sizeof(ans));
	memset(val, 0x3f, sizeof(val));
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
		int u &#x3D; std::max(h[i], h[i + 1]);
		vec[sa[i] + u].push_back(sa[i]);
		if (sa[i] + u &lt;&#x3D; n) &#123;
			&#x2F;&#x2F;for (j &#x3D; sa[i]; j &lt;&#x3D; n; j++) ans[j] &#x3D; std::min(ans[j], std::max(j - sa[i] - u, 0) + u + 1);
			q1 &#x3D; sa[i], q2 &#x3D; sa[i] + u, q3 &#x3D; u + 1;
			change(1, 1, n);
		&#125;
	&#125;
	get(1, 1, n, 1e9);
	int mx &#x3D; -1e9;
	for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
		for (j &#x3D; 0; j &lt; vec[i].size(); j++) mx &#x3D; std::max(vec[i][j], mx);
		printf(&quot;%d\n&quot;, std::min(i - mx + 1, ans[i]));
	&#125;
&#125;
</code></pre></p><h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>后缀自动机 - 陈立杰 <em>应该是某年 WC 的讲稿</em></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://huntzhan.org/suffix-automaton-tutorial/">不太好打开的一篇文章(番羽 土啬 好像可以上)</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://blog.csdn.net/wmdcstdio/article/details/44780707">萌帝翻译</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://fanhq666.blog.163.com/blog/static/8194342620123352232937/">fhq</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://lazycal.logdown.com/posts/195299-suffix-automaton-summary">lazycal(里面也有很多很好的参考资料)</a></li><li>15年集训队论文<br>推荐阅读顺序123546</li></ol><hr><p>广义sam<br><a target="_blank" rel="noopener external nofollow noreferrer" href="http://dwjshift.logdown.com/posts/304570">dwj</a><br>15年论文（注意15年有两篇关于sam的，这是第一篇）</p><h3 id="Problems-Set"><a href="#Problems-Set" class="headerlink" title="Problems Set"></a>Problems Set</h3><div class="table-container"><table><thead><tr><th>Prob</th><th>Hint</th></tr></thead><tbody><tr><td>SUBLEX</td><td>字典序第k大子串 sam（也可以sa</td></tr><tr><td>LCS</td><td>用一个串建sam，用第二个串跑</td></tr><tr><td>LCS2</td><td>上题的直接扩展</td></tr><tr><td>2882 工艺</td><td>最小循环表示。sam/sa都很简单</td></tr><tr><td>4516 生成魔咒</td><td>输出每个前缀的不同子串。sam本来就支持在线算</td></tr><tr><td>4199 品酒大会</td><td>还是按lcp统计</td></tr><tr><td>3172 单词</td><td>先拼出论文建sam，再把每个单词放进去，输出right集合大小即为出现次数</td></tr><tr><td>2555 SubString</td><td>意思是强制在线维护right。每次np实际上是从np到根right+1的修改操作，可以lct（避免了ett）</td></tr><tr><td>3926 诸神眷恋的幻想乡</td><td>广义sam</td></tr><tr><td>4566 找相同子串</td><td>广义sam</td></tr><tr><td>2946 公共串</td><td>嗯，还是个多串lcs问题。不过这次用广义sam写了。</td></tr><tr><td>2806 Cheat</td><td>sam dp</td></tr><tr><td>3998 弦论</td><td>sublex</td></tr><tr><td>3673 回文串</td><td>没搞懂</td></tr><tr><td>3277 串</td><td>神</td></tr></tbody></table></div></div></article><div class="page-nav"><div class="underline-trans"><a href="/2016/2-SAT/">◀ 求解 2-SAT</a></div><div class="underline-trans"><a href="/2016/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于动态规划的一点思考 ▶</a></div></div><section id="comments"><div id="disqus_thread"><script type="text/javascript">var disqus_shortname="rapiz";function loadDisqus(){var e=document,n=e.createElement("script");n.src="https://"+disqus_shortname+".disqus.com/embed.js",n.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(n),window.disqus_config=function(){this.page.url="https://rapiz.me/2016/StringAlgorithms/",this.page.identifier="/2016/StringAlgorithms/"}}var runningOnBrowser="undefined"!=typeof window,isBot=runningOnBrowser&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){var n;!isBot&&supportsIntersectionObserver?(n=new IntersectionObserver(function(e){e[0].isIntersecting&&(loadDisqus(),n.disconnect())},{threshold:[0]})).observe(document.getElementById("disqus_thread")):loadDisqus()},1)</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener external nofollow noreferrer" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></main><div id="typography-footer"><p>Powered by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1/typography">Typography</a> designed by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1">Rapiz</a></p></div></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>