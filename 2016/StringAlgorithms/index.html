<!DOCTYPE html>
<html>
<!DOCTYPE html>
<head>
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><title>
    字符串算法 |  潮与雪 - Rapiz
  </title>
  
<link rel="stylesheet" href="/css/style.css">
 
<script src="/js/utils.js"></script>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="robots" content="index,follow" />
  <meta name="author" content="Rapiz" />
  
  <meta name="keywords" content="潮与雪,Rapiz,Rapiz,OI,ACM,HUST,乔羽佳,博客,Blog,算法,开源软件,题解,字符串,KMP,AC自动机,后缀数组,后缀自动机,Algorithm" />
  <meta name="description" content="潮与雪,Rapiz,凡人难以承受生活全部的真相，于是他们各执一端。,Rapiz,字符串算法,想起了从前被字符串支配的恐惧" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <script src="https://cdn.jsdelivr.net/npm/mermaid@8.5.1/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({ theme: "neutral" });
    }
  </script>
  
<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="潮与雪" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="潮与雪" type="application/rss+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<div id = "wrap">
    <header id="header">
  <div id="nav">
    <div id="nav-items">
      
      <div class="underline-trans">
        <a href="/">Home</a>
      </div>
      
      <div class="underline-trans">
        <a href="/links">Links</a>
      </div>
      
      <div class="underline-trans">
        <a href="/portal">About</a>
      </div>
      
    </div>
  </div>
</header>

	<main class = 'main' onchange="FanfouFix();">
		<article class="post markdown-body">
  <div class="post-title">
    <h1 class="title">字符串算法</h1>
  </div>
   <div class="post-meta">
         
    <blockquote>想起了从前被字符串支配的恐惧</blockquote>
    
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7"><span class="toc-text">记号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#border"><span class="toc-text">border</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NOI2014-%E5%8A%A8%E7%89%A9%E5%9B%AD"><span class="toc-text">NOI2014 动物园</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BZOJ3620-%E6%A2%A6%E4%B8%AD%E6%9B%BE%E8%A7%81"><span class="toc-text">BZOJ3620 梦中曾见</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BZOJ4698-SDOI2008-Sandy%E7%9A%84%E5%8D%A1%E7%89%87"><span class="toc-text">BZOJ4698 SDOI2008 Sandy的卡片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AC-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">AC 自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="toc-text">后缀数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3238-%E5%B7%AE%E5%BC%82"><span class="toc-text">3238 差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3230-%E7%9B%B8%E4%BC%BC%E5%AD%90%E4%B8%B2"><span class="toc-text">3230 相似子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2251-%E5%A4%96%E6%98%9F%E8%81%94%E7%BB%9C"><span class="toc-text">2251 外星联络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2"><span class="toc-text">1396 识别子串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">后缀自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problems-Set"><span class="toc-text">Problems Set</span></a></li></ol></li></ol>
    <span class="post-author">By Rapiz</span>
    <span class="post-time">2016-11-01</span>
    <span class="post-tags">
      <a class="article-tag-none-link" href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC自动机</a>, <a class="article-tag-none-link" href="/tags/KMP/" rel="tag">KMP</a>, <a class="article-tag-none-link" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="tag">后缀数组</a>, <a class="article-tag-none-link" href="/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">后缀自动机</a>, <a class="article-tag-none-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a>
      
    </span>
</div>
  <div class="post-content">
    </p>
<h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>在本文中，一般有<br>n 为字符串长度。<br>[l, r] 为字符串的一个子串（闭区间）。<br>[pos] 为第pos个字符。<br>pre(i) 表示字符串的长度为 i 的前缀。<br>suf(i) 表示字符串的长度为 i 的后缀。<br>下标从 1 开始。</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>前置知识：理解 KMP 模板<br>O(N) 求出 1…n 的 <em>最长非原串</em>border</p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若 pre(i) ==  suf(i)， 我们把 i 叫做这个字符串的一个 border。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>性质1：<br>若一个字符串存在一个长为 b 的 border， 那么 n - b 是这个字符串的一个循环节。<br><em>此时我们说的循环节允许最后一个循环节不完整出现，比如12312312也可以有循环节123</em><br>证明：<br>虽然看上去很厉害，不过证明相当简单。<br>设循环节长 $l = n - b$<br>求证即为</p>
<script type="math/tex; mode=display">\forall i \in [1, n - l], [i] = [i + l]</script><p>因为存在长为 b 的 border，那么根据 border 的定义有：</p>
<script type="math/tex; mode=display">\forall i \in [1, b], [i] = [n - b + i]</script><p>接下来做的事情，就是将 $l = n - b$ 这个式子代入上式来消去 $b,n$，就证完了！<script type="math/tex">\forall i \in [1, n - l], [i] = [l + i]</script></p>
<p>性质2:<br>border 的 border 还是 border<br>太简单了不写了。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>1009 GT考试</td>
<td>KMP思路的dp，矩阵加速dp</td>
</tr>
<tr>
<td>1355 Radio</td>
<td>border直接应用</td>
</tr>
<tr>
<td>3670 动物园</td>
<td>求不重叠border</td>
</tr>
<tr>
<td>3620 梦中曾见</td>
<td>求某个范围的border是否存在</td>
</tr>
<tr>
<td>4698 Sandy的卡片</td>
<td>最长公共子串</td>
</tr>
<tr>
<td>3942 Censor</td>
<td>需要栈</td>
</tr>
</tbody>
</table>
</div>
<h4 id="NOI2014-动物园"><a href="#NOI2014-动物园" class="headerlink" title="NOI2014 动物园"></a>NOI2014 动物园</h4><p>维护两个东西：<br>p2, 前 i 个字符的小于等于n/2的最长 border<br>num[i], 前 i 个字符的最长 border 含有多少 border<br>KMP 主要利用了性质2。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define file(x) &quot;zoo.&quot;#x
typedef long long ll;
const int L = 1e6 + 1;
const ll M = 1e9 + 7;
char s[L];
ll nxt[L], num[L];
ll solve() &amp;#123;
    int n = strlen(s + 1);
    ll res = 1;
    int p = 0, p2 = 0;
    num[1] = 1;
    for (int i = 2; i &lt;= n; i++) &amp;#123;
        while (p &amp;&amp; s[p + 1] != s[i]) p = nxt[p];
        if (s[p + 1] == s[i]) p++;
        nxt[i] = p;
        num[i] = num[p] + 1;
        while (p2 &amp;&amp; s[p2  + 1] != s[i]) p2 = nxt[p2];
        if (s[p2 + 1] == s[i]) p2++;
        while (p2*2 &gt; i) p2 = nxt[p2];
        res = (res*(num[p2] + 1))%M;
    &amp;#125;
    return res;
&amp;#125;
int main() &amp;#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s + 1), printf(&quot;%lld\n&quot;, solve());
&amp;#125;
</code></pre>
<h4 id="BZOJ3620-梦中曾见"><a href="#BZOJ3620-梦中曾见" class="headerlink" title="BZOJ3620 梦中曾见"></a>BZOJ3620 梦中曾见</h4><p>判断有长度在[k,len(s)/2]的 border 的子串 s 有多少个。<br>我们可以求出最长的「中间有空」的 border，然后判断是否不小于 k。<br>这个 border 的求法和动物园中的差不多。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int L = 15010;
int n, nxt[L], k;
long long ans;
char buf[L &lt;&lt; 1];
int main() &amp;#123;
    scanf(&quot;%s%d&quot;, buf + 1, &amp;k);
    for (char* s = buf; s == buf || *s; s++) &amp;#123;
        for (int i = 2, p = 0, p2 = 0; s[i]; i++) &amp;#123;
            while (p &amp;&amp; s[p + 1] != s[i]) p = nxt[p];
            if (s[p + 1] == s[i]) p++;
            nxt[i] = p;
            while (p2 &amp;&amp; s[p2 + 1] != s[i]) p2 = nxt[p2];
            if (s[p2 + 1] == s[i]) p2++;
            while (p2*2 + 1 &gt; i) p2 = nxt[p2];
            if (p2 &gt;= k) ans++;
        &amp;#125;
    &amp;#125;
    printf(&quot;%lld\n&quot;, ans);
&amp;#125;
</code></pre>
<h4 id="BZOJ4698-SDOI2008-Sandy的卡片"><a href="#BZOJ4698-SDOI2008-Sandy的卡片" class="headerlink" title="BZOJ4698 SDOI2008 Sandy的卡片"></a>BZOJ4698 SDOI2008 Sandy的卡片</h4><p>题目中给出的条件可以转化为，两个序列差分后，除了第一项都相同。<br>在这个相等意义下的最长公共子串。<br>所以我们先将所有子串都差分。<br>然后枚举第一个串的一个后缀，在所有串上跑 KMP，对这些串上的匹配长度取最小值，就是当前后缀的答案。然后对所有后缀的答案取最大值。<br>注意跑 KMP 的时候强制让第一个字符匹配上，这是这题的相等条件。怎么强制看代码。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
const int N = 1010, L = 110;
int n, len[N], a[N][L], ans, nxt[L];
int main() &amp;#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) &amp;#123;
        scanf(&quot;%d&quot;, len + i);
        for (int j = 1; j &lt;= len[i]; j++) scanf(&quot;%d&quot;, &amp;a[i][j]);
        for (int j = len[i]; j; j--) a[i][j] -= a[i][j - 1];
        a[i][1] = 1;
    &amp;#125;
    if (n == 1) ans = len[1];
    for (int* s = a[1], cnt = 1; cnt &lt;= len[1]; s++, cnt++) &amp;#123;
        int ll = len[1] - (s - a[1]);
        for (int i = 2, p = 0; i &lt;= ll; i++) &amp;#123;
            while (p &amp;&amp; s[p + 1] !=  s[i]) p = nxt[p];
            if (!p || s[p + 1] == s[i]) p++;
            nxt[i] = p;
        &amp;#125;
        int an = 1e9;
        for (int i = 2; i &lt;= n; i++) &amp;#123;
            int* t = a[i], nn = 0;
            for (int j = 1, p = 0; j &lt;= len[i]; j++) &amp;#123;
                while (p &amp;&amp; s[p + 1] != t[j]) p = nxt[p];
                if (!p || s[p + 1] == t[j]) p++;
                nn = std::max(nn, p);
                if (p == ll) break;
            &amp;#125;
            an = std::min(an, nn);
        &amp;#125;
        if (an != 1e9) ans = std::max(ans, an);
    &amp;#125;
    printf(&quot;%d\n&quot;, ans);
&amp;#125;
</code></pre>
<h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><p>不少题会在上面dp，走多少步怎么怎么样的方法数，可以用矩阵乘法。这个没什么说的。</p>
<p>然后就是插入一个串记录匹配次数。暴力方法是每到一个节点都把fail能走到的节点cnt++。不那么暴力的方法就是最后再按倒bfs序 cnt[fail[x]] += cnt[x]。<br>还有一种角度，把fail指针看成父指针，我们就得到了一颗fail树。这样每次匹配就是某个节点一直到根节点的树链上的点都cnt++。<br>或者不向上更新，每次只让一个点cnt++。考虑它的影响：对，就是他所有祖先实际上都被匹配了一次。那我们可以不修改他们，而是询问他们的子树和来得到他们被匹配的次数。这其实算是树上的技巧。主要在NOI打字机那道题里用了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>1030 文本生成器</td>
<td>dp</td>
</tr>
<tr>
<td>2938 病毒</td>
<td>拓扑排序</td>
</tr>
<tr>
<td>2434 阿狸的打字机</td>
<td>fail树</td>
</tr>
<tr>
<td>2754 喵星球上的点名</td>
<td>出题人——消音——</td>
</tr>
<tr>
<td>2580 VideoGame</td>
<td>dp</td>
</tr>
</tbody>
</table>
</div>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>先做完罗穗骞论文里的题。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>1031-JSOI2007-字符加密Cipher</td>
<td>复制粘贴一次再遍历sa，忽略不合法的后缀即可</td>
</tr>
<tr>
<td>1692 队列变换</td>
<td>贪心策略。sa用来比较前缀后缀字典序</td>
</tr>
<tr>
<td>3238 差异</td>
<td>数学+sa+单调栈</td>
</tr>
<tr>
<td>2251 2010BeijingWc 外星联络</td>
<td>出现至少两次的子串个数。sub[i] = sub[i - 1] + n - sa[i] + 1 - h[i]可得长度从h[i]+1开始</td>
</tr>
<tr>
<td>3230 相似子串</td>
<td>sa，用上式算出子串数，二分定位子串位置，计算长度。然后再算最长公共前缀和后缀</td>
</tr>
<tr>
<td>1396 识别子串</td>
<td>sa+线段树（试手标记永久化的好机会）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="3238-差异"><a href="#3238-差异" class="headerlink" title="3238 差异"></a>3238 差异</h4><p>那个len的求和自己推式子吧。化到一个sigma就可以用了（on）。<br>然后后面那个求和我们能看出来是对所有后缀之间的lcp长度求和。<br>所以在height数组上，对于每个i，我们求后缀sa<a href="1 &lt;= k &lt;= i">k</a>与sa[i]的lcp（也就是一段数的最小值）加起来就好了。<br>这个东西就和后缀数组没关系了，单纯的优化一些数求和的问题。<br>可以用单调栈解决。单调栈中维护有前面num个后缀到现在的最小值是val。再维护单调栈中val x num。每次答案加上val x num就行了。</p>
<p>如果你感觉单调栈写起来很迷，那可能是因为这里没搞清楚：</p>
<pre><code class="lang-plain">sa[i-1]       sa[i]
      \ h[i] /
</code></pre>
<p>看完再想想单调栈究竟在维护什么，看我代码也行。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
const int N = 5e5 + 10;
typedef long long ll;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N], top;
char s[N];
struct T&amp;#123;ll v, n;&amp;#125;sk[N];
ll ans;
inline bool cmp(int a, int b, int j) &amp;#123;return rk[a] == rk[b] &amp;&amp; rk[a + j] == rk[b + j];&amp;#125;
int main() &amp;#123;
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1);
    m = 256;
    int i, j, p;
    for (i = 1; i &lt;= n; i++) sa[i] = i, rk[i] = s[i],
        ans += (n + 1ll)*(n - i) - (i + 1ll + n)*(n - i)/2 + (n + 1ll)*(i - 1) - i*(i - 1ll)/2;
    for (j = 0; j &lt;= n; m = p, j ? j&lt;&lt;=1:j=1) &amp;#123;
        for (i = n - j + 1, p = 0; i &lt;= n; i++) a[++p] = i;
        memset(c, 0, sizeof(int)*(m + 1));
        for (i = 1; i &lt;= n; i++) &amp;#123;
            if (sa[i] - j &gt; 0) a[++p] = sa[i] - j;
            c[rk[i]]++;
        &amp;#125;
        for (i = 1; i &lt;= m; i++) c[i] += c[i - 1];
        for (i = n; i; i--) sa[c[rk[a[i]]]--] = a[i];
        for (i = 1, p = 0 ; i &lt;= n; i++) b[sa[i]] = cmp(sa[i], sa[i - 1], j) ? p:++p;
        memcpy(rk, b, sizeof(int)*(n + 1));
    &amp;#125;
    for (p = 0, i = 1; i &lt;= n; h[rk[i++]] = p)
        for (p?p--:0, j = sa[rk[i] - 1]; s[i + p] == s[j + p]; p++);
    ll sum = 0;
    for (i = 1; i &lt;= n; i++) &amp;#123;
        ll cnt = 0;
        if (i &gt; 1) cnt++;
        while (top &amp;&amp; sk[top - 1].v &gt;= h[i]) &amp;#123;
            top--;
            cnt += sk[top].n;
            sum -= sk[top].n*sk[top].v;
        &amp;#125;
        sum += h[i]*cnt;
        ans = ans - 2*sum;
        sk[top++] = (T)&amp;#123;h[i], cnt&amp;#125;;
    &amp;#125;
    printf(&quot;%lld\n&quot;, ans);
&amp;#125;
</code></pre>
<h4 id="3230-相似子串"><a href="#3230-相似子串" class="headerlink" title="3230 相似子串"></a>3230 相似子串</h4><p>我们回顾一下论文内容，本质不同的子串数目。考虑按sa顺序，每次加进来一个后缀，新产生 n - sa[i] + 0 个子串，其中 h[i] 个与前面的重复，所以新产生的本质不同的子串数目是前者减去后者。<br>再想想，新产生的这些子串是哪些呢？<br>是起点在 sa[i]，终点必须严格大于 h[i] 的这些串。因为终点不到 h[i] 的都可以成为 sa[i-1] 的一个前缀，这说明他们在前面已经存在了。</p>
<p>然后根据以上我们就能二分出字典序中第x个子串是哪个后缀的前缀。设是第k个后缀。长度就是x-sub[k]+h[i]。加h[i]的原因见上面一行。<br>然后我们就知道了串的开头和结尾位置。剩下的就是个基本应用了。</p>
<p>实现上有点技巧。一定注意为了求公共前缀/后缀这里不能分隔符再倒着写一边。这样就没办法用这个后缀数组找子串位置了。所以可以先找出位置再这样reverse算。<br>注意子串个数和输入的询问都会爆int，巨坑</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min;
const int N = 2e5 + 10;
int n, m, q,  a[N], b[N], c[N], sa[N], rk[N], h[23][N], start[N][2], end[N][2];
long long ans[N], sub[N];
char s[N];
inline bool cmp(int a, int b, int j) &amp;#123;return rk[a] == rk[b] &amp;&amp; rk[a + j] == rk[b + j];&amp;#125;
inline long long query(int l, int r) &amp;#123;
    if (l == r) return n - l + 1;
    l = rk[l], r = rk[r];
    if (l &gt; r) std::swap(l, r);
    l++;
    int k = r - l + 1, p = 0;
    while ((1 &lt;&lt; p + 1) &lt;= k) p++;
    return min(h[p][l], h[p][r - (1 &lt;&lt; p) + 1]);
&amp;#125;
void build() &amp;#123;
    m = 256;
    int i, j, p;
    memset(rk, 0, sizeof(rk));
    for (i = 1; i &lt;= n; i++) sa[i] = i, rk[i] = s[i];
    for (j = 0; j &lt;= n; m = p, j?j&lt;&lt;=1:j=1)&amp;#123;
        for (i = n - j + 1, p = 0; i &lt;= n; i++) a[++p] = i;
        memset(c, 0, sizeof(int)*(m + 1));
        for (i = 1; i &lt;= n; i++) &amp;#123;
            c[rk[i]]++;
            if (sa[i] - j &gt; 0) a[++p] = sa[i] - j;
        &amp;#125;
        for (i = 1; i &lt;= m; i++) c[i] += c[i - 1];
        for (i = n; i; i--) sa[c[rk[a[i]]]--] = a[i];
        for (p = 0, i = 1; i &lt;= n; i++) b[sa[i]] = cmp(sa[i], sa[i - 1], j) ? p : ++p;
        memcpy(rk, b, sizeof(int)*(n + 1));
    &amp;#125;
    for (p = 0, i = 1; i &lt;= n; h[0][rk[i++]] = p)
        for (p?p--:0, j = sa[rk[i] - 1]; s[i + p] == s[j + p]; p++);
    for (i = 1; i &lt; 23; i++) for (j = 1; j &lt;= n; j++) if (j + (1 &lt;&lt; i - 1) &lt;= n)
        h[i][j] = min(h[i - 1][j], h[i - 1][j + (1 &lt;&lt; i - 1)]);
    for (i = 1; i &lt;= n; i++) sub[i] = sub[i - 1] + n - sa[i] + 1 - h[0][i];
&amp;#125;
int main() &amp;#123;
//    freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%d%s&quot;, &amp;n, &amp;q, s + 1);
    build();
    for (int i = 1; i &lt;= q; i++) &amp;#123;
        long long x, y;
        scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
        int px = std::lower_bound(sub + 1, sub + n + 1, x) - sub, py = std::lower_bound(sub + 1, sub + 1 + n, y) - sub;
        if (px &gt; n || py &gt; n) &amp;#123;
            ans[i] = -1;
            continue;
        &amp;#125;
        x = x - sub[px - 1] + h[0][px], y = y - sub[py - 1] + h[0][py];
        px = sa[px], py = sa[py];
        start[i][0] = px, start[i][1] = py, end[i][0] = px + x - 1, end[i][1] = py + y - 1;
        long long pre = min(query(px, py), min(x, y));
        ans[i] += pre*pre;
    &amp;#125;
    std::reverse(s + 1, s + 1 + n);
    build();
    for (int i = 1; i &lt;= q; i++) if (ans[i] != -1) &amp;#123;
        long long suf = min(query(n - end[i][0] + 1, n - end[i][1] + 1), (long long)min(end[i][0] - start[i][0] + 1, end[i][1] - start[i][1] + 1));
        ans[i] += suf*suf;
    &amp;#125;
    for (int i = 1; i &lt;= q; i++) printf(&quot;%lld\n&quot;, ans[i]);
&amp;#125;
//子串个数会爆int，输入询问同理
</code></pre>
<h4 id="2251-外星联络"><a href="#2251-外星联络" class="headerlink" title="2251 外星联络"></a>2251 外星联络</h4><p>直接看代码末尾的那几行吧。<br>为什么从 h[i] + 1 开始枚举？<br>想想上一题就知道了。这保证我们每次枚举到的串都不存在于前面，也就是没有把本质相同的串多输出了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
const int N = 6010;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N];
char s[N];
inline bool cmp(int a, int b, int j) &amp;#123;return rk[a] == rk[b] &amp;&amp; rk[a + j] == rk[b + j];&amp;#125;
int main() &amp;#123;
//    freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%s&quot;, &amp;n, s + 1);
    m = 256;
    int i, j, p;
    for (i = 1; i &lt;= n; i++) sa[i] = i, rk[i] = s[i];
    for (j = 0; j &lt;= n; m = p, j?j&lt;&lt;=1:j=1) &amp;#123;
        for (i = n - j + 1, p = 0; i &lt;= n; i++) a[++p] = i;
        for (i = 1; i &lt;= n; i++) if (sa[i] - j &gt; 0) a[++p] = sa[i] - j;
        memset(c, 0, sizeof(int)*(m + 1));
        for (i = 1; i &lt;= n; i++) c[rk[i]]++;
        for (i = 1; i &lt;= m; i++) c[i] += c[i - 1];
        for (i = n; i; i--) sa[c[rk[a[i]]]--] = a[i];
        for (i = 1, p = 0; i &lt;= n; i++) b[sa[i]] = cmp(sa[i], sa[i - 1], j) ? p : ++p;
        memcpy(rk, b, sizeof(int)*(n + 1));
    &amp;#125;
    for (p = 0, i = 1; i &lt;= n; h[rk[i++]] = p)
        for(p?p--:0, j = sa[rk[i] - 1]; s[i + p] == s[j + p]; p++);
    for (i = 1; i &lt;= n; i++)
        for (int j = h[i] + 1; sa[i] + j - 1 &lt;= n; j++) &amp;#123;
            int r = i, l = i;
            //while (l &gt;= 1 &amp;&amp; h[l] &gt;= j) l--;
            while (r + 1 &lt;= n &amp;&amp; h[r + 1] &gt;= j) r++;
            if (r - l + 1 &gt; 1) printf(&quot;%d\n&quot;, r - l + 1);
        &amp;#125;
&amp;#125;
</code></pre>
<h4 id="1396-识别子串"><a href="#1396-识别子串" class="headerlink" title="1396 识别子串"></a>1396 识别子串</h4><p>题目要求识别子串不能重复出现。<br>我们不妨考虑不重复出现的子串覆盖到了哪些字符。<br>还是按sa顺序来考虑sa[i]的前缀来考虑所有子串。<br>sa[i]有多少前缀重复出现过了？L = max(h[i], h[i + 1])就是其他地方出过的最长前缀。<br>这意味着从 L + 1 开始的子串都是合法的——没有重复出现过。<br>这样，{sa[i],L+1}这一个串可以成为它覆盖到的字符的识别串，长度显然。这里用个线段树把区间答案min了。<br>然后考虑sa[i]的其他合法前缀，L+2 … n 依然对覆盖到的字符有贡献，设这个字符位置为 p， 贡献就是 p - sa[i] + 1，其中 p &gt;= L + 2。<em>p也可以取到L+1，这时和上一行的情况贡献一样。</em><br>然后我们可以用个vector，把sa[i]放到位置L+2里。这个计算过程估计用代码（在我代码的末尾部分）可以看得更清楚，毕竟是非常直观的算法。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
const int N = 2e5 + 10;
int n, m, a[N], b[N], c[N], sa[N], rk[N], h[N], ans[N], val[N &lt;&lt; 2];
char s[N];
std::vector&lt;int&gt; vec[N];
inline bool cmp(int a, int b, int j) &amp;#123;return rk[a] == rk[b] &amp;&amp; rk[a + j] == rk[b + j];&amp;#125;
int q1, q2, q3;
void change(int o, int l, int r) &amp;#123;
    if (q1 &lt;= l &amp;&amp; r &lt;= q2) val[o] = std::min(val[o], q3);
    else &amp;#123;
        int mid = l + r &gt;&gt; 1;
        if (mid &gt;= q1) change(o&lt;&lt;1, l, mid);
        if (mid + 1 &lt;= q2) change(o&lt;&lt;1|1, mid + 1, r);
    &amp;#125;
&amp;#125;
void get(int o, int l, int r, int nv) &amp;#123;
    nv = std::min(nv, val[o]);
    int mid = l + r &gt;&gt; 1;
    if (l == r) ans[l] = nv;
    else get(o&lt;&lt;1, l, mid, nv), get(o&lt;&lt;1|1, mid+1, r, nv);
&amp;#125;
int main() &amp;#123;
//     freopen(&quot;input&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%s&quot;, s + 1);
    int i, j, p;
    for (i = 1; s[i]; i++) n++, sa[i] = i, rk[i] = s[i];
    m = 256;
    for (j = 0; j &lt;= n; m = p, j?j&lt;&lt;=1:j=1) &amp;#123;
        for (i = n - j + 1, p = 0; i &lt;= n; i++) a[++p] = i;
        memset(c, 0, sizeof(int)*(m + 1));
        for (i = 1; i &lt;= n; i++) &amp;#123;
            c[rk[i]]++;
            if (sa[i] &gt; j) a[++p] = sa[i] - j;
        &amp;#125;
        for (i = 1; i &lt;= m; i++) c[i] += c[i - 1];
        for (i = n; i; i--) sa[c[rk[a[i]]]--] = a[i];
        for (i = 1, p = 0; i &lt;= n; i++) b[sa[i]] = cmp(sa[i], sa[i - 1], j) ? p : ++p;
        memcpy(rk, b, sizeof(int)*(n + 1));
    &amp;#125;
    for (i = 1, p = 0; i &lt;= n; h[rk[i++]] = p)
        for (p?p--:0, j = sa[rk[i] - 1]; s[i + p] == s[j + p]; p++);
    memset(ans, 0x3f, sizeof(ans));
    memset(val, 0x3f, sizeof(val));
    for (i = 1; i &lt;= n; i++) &amp;#123;
        int u = std::max(h[i], h[i + 1]);
        vec[sa[i] + u].push_back(sa[i]);
        if (sa[i] + u &lt;= n) &amp;#123;
            //for (j = sa[i]; j &lt;= n; j++) ans[j] = std::min(ans[j], std::max(j - sa[i] - u, 0) + u + 1);
            q1 = sa[i], q2 = sa[i] + u, q3 = u + 1;
            change(1, 1, n);
        &amp;#125;
    &amp;#125;
    get(1, 1, n, 1e9);
    int mx = -1e9;
    for (i = 1; i &lt;= n; i++) &amp;#123;
        for (j = 0; j &lt; vec[i].size(); j++) mx = std::max(vec[i][j], mx);
        printf(&quot;%d\n&quot;, std::min(i - mx + 1, ans[i]));
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>后缀自动机 - 陈立杰 <em>应该是某年 WC 的讲稿</em></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://huntzhan.org/suffix-automaton-tutorial/">不太好打开的一篇文章(番羽 土啬 好像可以上)</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://blog.csdn.net/wmdcstdio/article/details/44780707">萌帝翻译</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://fanhq666.blog.163.com/blog/static/8194342620123352232937/">fhq</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://lazycal.logdown.com/posts/195299-suffix-automaton-summary">lazycal(里面也有很多很好的参考资料)</a></li>
<li>15年集训队论文<br>推荐阅读顺序123546</li>
</ol>
<hr>
<p>广义sam<br><a target="_blank" rel="noopener external nofollow noreferrer" href="http://dwjshift.logdown.com/posts/304570">dwj</a><br>15年论文（注意15年有两篇关于sam的，这是第一篇）</p>
<h3 id="Problems-Set"><a href="#Problems-Set" class="headerlink" title="Problems Set"></a>Problems Set</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Prob</th>
<th>Hint</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUBLEX</td>
<td>字典序第k大子串 sam（也可以sa</td>
</tr>
<tr>
<td>LCS</td>
<td>用一个串建sam，用第二个串跑</td>
</tr>
<tr>
<td>LCS2</td>
<td>上题的直接扩展</td>
</tr>
<tr>
<td>2882 工艺</td>
<td>最小循环表示。sam/sa都很简单</td>
</tr>
<tr>
<td>4516 生成魔咒</td>
<td>输出每个前缀的不同子串。sam本来就支持在线算</td>
</tr>
<tr>
<td>4199 品酒大会</td>
<td>还是按lcp统计</td>
</tr>
<tr>
<td>3172 单词</td>
<td>先拼出论文建sam，再把每个单词放进去，输出right集合大小即为出现次数</td>
</tr>
<tr>
<td>2555 SubString</td>
<td>意思是强制在线维护right。每次np实际上是从np到根right+1的修改操作，可以lct（避免了ett）</td>
</tr>
<tr>
<td>3926 诸神眷恋的幻想乡</td>
<td>广义sam</td>
</tr>
<tr>
<td>4566 找相同子串</td>
<td>广义sam</td>
</tr>
<tr>
<td>2946 公共串</td>
<td>嗯，还是个多串lcs问题。不过这次用广义sam写了。</td>
</tr>
<tr>
<td>2806 Cheat</td>
<td>sam dp</td>
</tr>
<tr>
<td>3998 弦论</td>
<td>sublex</td>
</tr>
<tr>
<td>3673 回文串</td>
<td>没搞懂</td>
</tr>
<tr>
<td>3277 串</td>
<td>神</td>
</tr>
</tbody>
</table>
</div>
  </div>
</article>

<div class='page-nav'>

  <div class='underline-trans'>
  <a href="/2016/2-SAT/">◀ 求解 2-SAT</a>
  </div>


  <div class='underline-trans'>
  <a href="/2016/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于动态规划的一点思考 ▶</a>
  </div>

</div>
<!-- 如果不是首页且没使用 `comments: false` 关闭评论，则尝试加载评论 -->

    <!-- 配置中启用多说时，导入相应代码 -->
    <!-- 以上皆关闭且 Hexo 配置中设置了 disqus_shortname 时，导入相应代码 -->
    
        <!-- 文件分离和变量的使用，使代码能较好的兼容 Hexo 主配置 -->
        <section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
    var disqus_shortname = 'rapiz'; // required: replace example with your forum shortname
    function loadDisqus() {
      // Disqus 安装代码
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      /*
      window.disqus_config = function () {
        this.page.url = [你的页面 URL];
        this.page.identifier = [你的页面的唯一辨识符];
      };
      */
      // 如果你和我一样在用 DisqusJS，loadDisqus() 里就应该是 DisqusJS 的初始化代码 new DisqusJS({...})
    }

    // 通过检查 window 对象确认是否在浏览器中运行
    var runningOnBrowser = typeof window !== "undefined";
    // 通过检查 scroll 事件 API 和 User-Agent 来匹配爬虫
    var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
    // 检查当前浏览器是否支持 IntersectionObserver API
    var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;

    // 一个小 hack，将耗时任务包裹在 setTimeout(() => { }, 1) 中，可以推迟到 Event Loop 的任务队列中、等待主调用栈清空后才执行，在绝大部分浏览器中都有效
    // 其实这个 hack 本来是用于优化骨架屏显示的。一些浏览器总是等 JavaScript 执行完了才开始页面渲染，导致骨架屏起不到降低 FCP 的优化效果，所以通过 hack 将耗时函数放到骨架屏渲染完成后再进行。
    setTimeout(function () {
      if (!isBot && supportsIntersectionObserver) {
        // 当前环境不是爬虫、并且浏览器兼容 IntersectionObserver API
        var disqus_observer = new IntersectionObserver(function(entries) {
          // 当前视窗中已出现 Disqus 评论框所在位置
          if (entries[0].isIntersecting) {
            // 加载 Disqus
            loadDisqus();
            // 停止当前的 Observer
            disqus_observer.disconnect();
          }
        }, { threshold: [0] });
        // 设置让 Observer 观察 #disqus_thread 元素
        disqus_observer.observe(document.getElementById('disqus_thread'));
      } else {
        // 当前环境是爬虫、或当前浏览器其不兼容 IntersectionObserver API
        // 直接加载 Disqus
        loadDisqus();
      }
    }, 1);
    /* * * DON'T EDIT BELOW THIS LINE * * */
    /*
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    */
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener external nofollow noreferrer" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

    


	</main>
  <div id = "typography-footer">
    <p>Powered by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1/typography">Typography</a> designed by <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Rapiz1">Rapiz</a></p>
</div>
<!-- Global site tag (gtag.js) - Google Analytics -->

<!-- End Google Analytics -->

</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<script src=https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
